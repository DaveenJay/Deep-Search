<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Search - Thinking Bots</title>
    <style>        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            background-color: #f8f9fa;
            color: #1d1d1f;
            overflow: hidden;
            height: 100vh;
        }
        
        .app-layout {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .sidebar {
            width: 350px;
            height: 100vh;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .sidebar-header {
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 20px;
        }
        
        .sidebar-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #28a745;
            margin: 0 0 5px 0;
        }
        
        .sidebar-subtitle {
            font-size: 0.9rem;
            color: #6c757d;
            margin: 0;
        }
        
        .main-content {
            flex: 1;
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 100%;
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .result-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }
        
        .tree-container {
            flex: 1;
            overflow: auto;
            margin-top: 20px;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .search-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        /* Status indicator for the main content */
        .status-bar {
            background-color: #343a40;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        
        .status-bar .status-text {
            flex: 1;
        }
        
        .status-bar .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: #28a745;
            box-shadow: 0 0 0 rgba(40, 167, 69, 0.4);
            animation: pulse 2s infinite;
        }
        
        .status-bar.inactive .status-indicator {
            background-color: #6c757d;
            animation: none;
        }
        
        /* Make the thinking detail panel fit better with the new layout */
        #thinking-detail {
            position: absolute;
            top: 70px;
            right: 20px;
            width: 500px;
            max-width: 40vw;
            height: calc(100vh - 100px);
            z-index: 100;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            margin-bottom: 15px;
            resize: vertical;
        }
        
        button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #218838;
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .api-key-input {
            margin-bottom: 20px;
        }
        
        .api-key-input input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .model-selector {
            margin-bottom: 20px;
        }
        
        .model-selector label {
            display: block;
            margin-bottom: 5px;
        }
        
        .model-selector select {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1rem;
            background-color: white;
        }
        
        .result-container {
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            display: none;
        }
        
        .result-heading {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .result-content {
            line-height: 1.6;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f8ff; /* Light blue background */
            border-radius: 5px;
            border: 1px solid #007bff;
            min-height: 100px; /* Ensure there's always visible space */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            font-size: 1.1rem; /* Slightly larger text */
        }
        
        .thinking-path {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
        }
        
        .thinking-path-title {
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .bot-thinking {
            background-color: #f0f0f0;
            border-left: 3px solid #28a745;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 0 5px 5px 0;
        }
        
        .bot-name {
            font-weight: 600;
            color: #28a745;
            margin-bottom: 5px;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .loading-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #28a745;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
            display: none;
        }
        
        .live-visualization {
            margin: 15px 0;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
        }
        
        .thinking-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border-left: 3px solid #28a745;
            animation: pulse 1.5s infinite;
        }
        
        .thinking-agent {
            font-weight: 600;
            color: #28a745;
            margin-right: 10px;
        }
        
        .thinking-dots {
            display: inline-block;
            width: 50px;
            text-align: left;
        }
        
        @keyframes thinking {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
            100% { content: ''; }
        }
        
        .thinking-dots::after {
            content: '';
            animation: thinking 1.5s infinite;
        }
        
        .live-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            position: relative;
            padding: 20px 10px;
            overflow: visible;
        }
        
        .live-node {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            margin: 5px;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 2;
        }
        
        .live-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5), 0 0 10px 2px rgba(40, 167, 69, 0.7);
        }
        
        .live-node.pending {
            background-color: #6c757d;
        }
        
        .live-node.processing {
            background-color: #007bff;
            animation: pulse 1.5s infinite;
        }
        
        .live-node.completed {
            background-color: #28a745;
        }
        
        .live-node.forwarded {
            background-color: #fd7e14;
        }
        
        .live-node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            bottom: 40px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .live-node:hover .live-node-tooltip {
            opacity: 1;
        }
        
        .live-node-children {
            display: flex;
            position: relative;
            justify-content: center;
            margin-top: 35px;
            min-width: 120px;
            padding-top: 15px;
        }
        
        .live-node-children::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            height: 15px;
            width: 2px;
            background-color: #28a745;
            transform: translateX(-50%);
        }
        
        .live-node-children.multiple-children::after {
            content: '';
            position: absolute;
            top: 0;
            left: 20%;
            width: 60%;
            height: 2px;
            background-color: #28a745;
        }
        
        .live-node-connector {
            position: absolute;
            top: -15px;
            left: 50%;
            width: 2px;
            height: 15px;
            background-color: #28a745;
            transform: translateX(-50%);
        }
        
        .live-node-children:not(.multiple-children) .live-node-connector {
            top: -35px;
            height: 35px;
        }
        
        .live-node.processing {
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5), 0 0 10px 2px rgba(0, 123, 255, 0.7);
        }
        
        .live-status {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        .activity-log {
            margin-top: 15px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.85rem;
            text-align: left;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .activity-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #dee2e6;
            color: #495057;
        }
        
        .activity-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .thinking-path {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
        }
        
        .thinking-path-title {
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .bot-thinking {
            background-color: #f0f0f0;
            border-left: 3px solid #28a745;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 0 5px 5px 0;
        }
        
        .bot-name {
            font-weight: 600;
            color: #28a745;
            margin-bottom: 5px;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tree View Styles - Revamped */
        .tree-container {
            overflow-x: auto;
            margin-top: 30px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .tree-view {
            position: relative;
            padding: 20px 0;
            min-height: 300px;
        }
        
        .tree-map {
            position: relative;
            margin: 0 auto;
        }
        
        .tree-level {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
        }
        
        .tree-node {
            background-color: white;
            border: 2px solid #28a745;
            border-radius: 6px;
            padding: 8px;
            margin: 0 8px;
            min-width: 140px;
            max-width: 170px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .tree-node:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .tree-node.selected {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        
        .tree-node-title {
            font-weight: 600;
            color: #28a745;
            margin-bottom: 5px;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .tree-node-content {
            font-size: 0.85rem;
            max-height: 80px;
            overflow-y: auto;
            padding: 6px;
            background-color: #f8f9fa;
            border-radius: 4px;
            color: #495057;
        }
        
        .tree-connector {
            position: absolute;
            pointer-events: none;
            stroke: #28a745;
            stroke-width: 2px;
            fill: none;
        }
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            color: white;
        }
        
        .status-badge.pending {
            background-color: #6c757d;
        }
        
        .status-badge.processing {
            background-color: #007bff;
            animation: pulse 1.5s infinite;
        }
        
        .status-badge.completed {
            background-color: #28a745;
        }
        
        .status-badge.forwarded {
            background-color: #fd7e14;
        }
        
        .tree-action-indicator {
            position: absolute;
            background-color: white;
            border: 1px solid #28a745;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #28a745;
            z-index: 2;
        }
        
        .tree-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            margin-right: 10px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        /* Thinking visualization */
        .thinking-bubble {
            position: absolute;
            background-color: #fff;
            border: 1px solid #28a745;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            z-index: 10;
            display: none;
            text-align: left;
            font-size: 0.85rem;
            line-height: 1.4;
            top: -5px;
            left: 105%;
        }
        
        .thinking-bubble::before {
            content: '';
            position: absolute;
            top: 15px;
            left: -8px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid #28a745;
        }
        
        .thinking-bubble::after {
            content: '';
            position: absolute;
            top: 15px;
            left: -7px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid #fff;
        }
        
        .arrow-connector {
            position: absolute;
            height: 40px;
            width: 40px;
            top: 50%;
            left: 100%;
            transform: translate(-50%, -50%);
            color: #28a745;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Thought process visualization */
        .thought-process {
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }
        
        .thought-process-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #28a745;
        }
        
        .thought-content {
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .thought-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 15px;
            margin-right: 5px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .thought-type.analytical {
            background-color: #cce5ff;
            color: #0066cc;
        }
        
        .thought-type.creative {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        
        .thought-type.decision {
            background-color: #d4edda;
            color: #155724;
        }
        
        .thought-type.questioning {
            background-color: #fff3cd;
            color: #856404;
        }
        
        /* Popover Styles for Detailed Thinking */
        .thinking-popover {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 25px;
            display: none;
        }
        
        .thinking-popover-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        
        .thinking-popover-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #28a745;
        }
        
        .thinking-popover-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
        }
        
        .thinking-popover-close:hover {
            color: #dc3545;
        }
        
        .thinking-popover-content {
            white-space: pre-wrap;
            line-height: 1.6;
        }
        
        .thinking-popover-section {
            margin-bottom: 20px;
        }
        
        .thinking-popover-section-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }
        
        /* Log View Styles */
        .log-container {
            background-color: #252525;
            color: #f0f0f0;
            border-radius: 10px;
            padding: 15px;
            margin-top: 30px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 6px;
            border-bottom: 1px solid #444;
            padding-bottom: 6px;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-time {
            color: #999;
            margin-right: 8px;
        }
        
        .log-level-info {
            color: #4dabf7;
        }
        
        .log-level-success {
            color: #69db7c;
        }
        
        .log-level-warning {
            color: #ffd43b;
        }
        
        .log-level-error {
            color: #ff6b6b;
        }
        
        .log-message {
            margin-left: 8px;
        }
        
        .log-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .log-toggle {
            background-color: #343a40;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        .log-clear {
            background-color: #495057;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        
        /* Rate limit status styles */
        .rate-limit-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        .progress {
            height: 8px;
            border-radius: 4px;
            background-color: #e9ecef;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #28a745;
            transition: width 0.5s ease;
        }
        
        /* Model badges */
        .model-badge {
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 5px;
            background-color: #e9ecef;
            color: #495057;
            display: inline-block;
        }
        
        .model-high {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        
        .model-medium {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .model-low {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        
        .node-name-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        /* Add CSS for the model info in thinking display */
        .thinking-header {
            margin-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 10px;
        }
        
        .thinking-model-info {
            font-size: 0.85rem;
            color: #6c757d;
            margin-top: 5px;
        }
        
        /* Add visual styles for continuations */
        .status-continued {
            background-color: #17a2b8;
            border-color: #0c839b;
        }
        
        .continuation-link {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            background-color: #17a2b8;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
        }

        .continuation-badge {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 15px;
            height: 15px;
            background-color: #17a2b8;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
        }

        .continuation-info {
            margin-top: 5px;
            font-size: 0.85rem;
            color: #17a2b8;
            padding: 4px 8px;
            background-color: rgba(23, 162, 184, 0.1);
            border-radius: 4px;
        }

        .continuation-label {
            font-weight: bold;
        }

        .continuation-info a {
            color: #138496;
            text-decoration: none;
        }

        .continuation-info a:hover {
            text-decoration: underline;
        }

        /* Thinking detail panel styles */
        #thinking-detail {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 500px;
            max-width: 40vw;
            height: calc(100vh - 100px);
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
        }

        .thinking-content {
            margin-top: 15px;
            line-height: 1.6;
        }

        /* Tree visualization styles */
        .tree-view {
            margin-top: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            min-height: 300px;
            overflow: auto;
        }

        .tree-map {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 40px;
            margin-top: 20px;
        }

        .tree-level {
            display: flex;
            justify-content: center;
            gap: 30px;
            position: relative;
        }

        .node {
            width: 180px;
            padding: 12px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid #e9ecef;
        }

        .node.active {
            box-shadow: 0 0 0 2px #28a745, 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .status-pending {
            border-left-color: #6c757d;
        }

        .status-processing {
            border-left-color: #fd7e14;
        }

        .status-completed {
            border-left-color: #28a745;
        }

        .status-forwarded {
            border-left-color: #007bff;
        }

        .status-continued {
            border-left-color: #17a2b8;
        }

        /* Loading spinner */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(2px);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(243, 243, 243, 0.3);
            border-top: 4px solid #28a745;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        .loading-text {
            color: #333;
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Legend styles */
        .tree-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #6c757d;
        }

        .status-badge {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .status-badge.pending {
            background-color: #6c757d;
            color: white;
        }

        .status-badge.processing {
            background-color: #fd7e14;
            color: white;
        }

        .status-badge.completed {
            background-color: #28a745;
            color: white;
        }

        .status-badge.forwarded {
            background-color: #007bff;
            color: white;
        }

        .status-badge.continued {
            background-color: #17a2b8;
            color: white;
        }

        /* Result container styles */
        .result-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .result-heading {
            font-size: 1.5rem;
            font-weight: 600;
            color: #28a745;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
        }

        .result-content {
            line-height: 1.6;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f8ff; /* Light blue background */
            border-radius: 5px;
            border: 1px solid #007bff;
            min-height: 100px; /* Ensure there's always visible space */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            font-size: 1.1rem; /* Slightly larger text */
        }

        .thinking-path {
            margin-top: 30px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }

        .thinking-path-title {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 15px;
            color: #495057;
        }

        /* Make textarea and inputs better */
        textarea, input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-family: inherit;
            font-size: 1rem;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1rem;
            margin-bottom: 15px;
            background-color: white;
        }

        button {
            padding: 10px 16px;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .app-layout {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: none;
                overflow: visible;
            }
            
            .main-content {
                height: auto;
                min-height: 60vh;
            }
            
            #thinking-detail {
                position: fixed;
                top: 20px;
                right: 20px;
                left: 20px;
                width: auto;
                max-width: calc(100% - 40px);
                height: calc(100vh - 40px);
            }
        }

        /* Empty state for tree view */
        .tree-view:empty::before {
            content: "Start a search to see agent collaboration in action";
            display: block;
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            color: #6c757d;
            font-style: italic;
            font-size: 0.9rem;
        }

        /* Improved tree connector styles */
        .tree-connector-container {
            z-index: 0;
        }

        path.connector {
            stroke: #ced4da;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 4 2;
        }

        path.connector.active {
            stroke: #28a745;
            stroke-dasharray: none;
        }

        /* Make the thinking detail panel look better */
        #thinking-detail {
            display: none;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 20px;
            overflow-y: auto;
        }

        .thinking-close-btn:hover {
            color: #dc3545;
        }

        /* Bot thinking display in results area */
        .bot-thinking {
            margin-bottom: 20px;
            border-left: 3px solid #e9ecef;
            padding-left: 15px;
        }

        .bot-name {
            font-weight: 500;
            color: #495057;
            margin-bottom: 8px;
        }

        /* Fix spacing issues */
        .api-key-input, .model-selector {
            margin-bottom: 15px;
        }

        textarea {
            margin-bottom: 10px;
        }

        /* Create a settings panel that overlays on the screen */
        .settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .settings-content {
            background-color: white;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .settings-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: #333;
        }
        
        .settings-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        
        .settings-close:hover {
            color: #333;
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2rem;
            color: #444;
        }
        
        /* Settings button in sidebar */
        .settings-button {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            padding: 8px 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            color: #495057;
            font-weight: 500;
        }
        
        .settings-button:hover {
            background-color: #e9ecef;
        }
        
        .settings-button i {
            margin-right: 8px;
        }

        /* Segmented Picker Styles */
        .view-selector {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #dee2e6;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .view-selector-option {
            padding: 12px 30px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: none;
            font-weight: 500;
            color: #495057;
            transition: all 0.3s ease;
            position: relative;
            font-size: 1.1rem;
            outline: none;
        }
        
        .view-selector-option:first-child {
            border-radius: 7px 0 0 7px;
        }
        
        .view-selector-option:last-child {
            border-radius: 0 7px 7px 0;
        }
        
        .view-selector-option.active {
            background-color: #007bff;
            color: white;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            transform: scale(1.05);
            z-index: 2;
        }
        
        .view-selector-option:hover:not(.active) {
            background-color: #e9ecef;
            transform: translateY(-2px);
        }
        
        .view-selector-option:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: transparent;
            transition: background-color 0.3s ease;
        }
        
        .view-selector-option.active:after {
            background-color: #28a745;
        }
        
        /* Notification dot for the answer tab */
        .view-selector-option .notification-dot {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            background-color: #dc3545;
            border-radius: 50%;
            display: none;
        }
        
        .view-selector-option .notification-dot.visible {
            display: block;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.8; }
        }
        
        /* View Container Styles */
        .view-container {
            display: none; /* Start hidden by default */
            height: calc(100% - 70px); /* Adjust height to account for the selector */
            width: 100%;
            overflow: hidden; /* Prevent scrolling at this level */
            transition: opacity 0.3s ease; /* Smooth transition between views */
            opacity: 0;
        }
        
        .view-container.active {
            display: block;
            opacity: 1;
        }
        
        /* Tree View Enhancements for more space */
        .agents-view {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .tree-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100% - 40px); /* Account for the view header */
            overflow: hidden; /* Prevent scrolling at container level */
        }
        
        #tree-view {
            flex: 1;
            height: calc(100% - 40px); /* Account for the legend */
            min-height: 400px;
            overflow: auto;
            padding: 10px;
        }
        
        .tree-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 6px 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.85rem;
        }
        
        /* Answer View */
        .answer-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: auto;
            padding: 0 20px;
        }
        
        #answer-view.active {
            display: block !important; /* Force display when active */
        }
        
        /* Force visibility for result container */
        #result-container {
            display: block !important; /* Always display */
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        /* Banner for answer notification */
        .answer-ready-banner {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
            text-align: center;
            font-weight: 500;
        }
        
        .answer-ready-banner.visible {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .answer-ready-banner button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .answer-ready-banner button:hover {
            background-color: #218838;
        }
        
        /* View switch hint in answer view */
        .view-switch-hint {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-left: 4px solid #28a745;
        }
        
        .view-switch-button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .view-switch-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .view-switch-button i {
            margin-right: 8px;
        }
        
        .view-switch-hint span {
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <div class="sidebar">
            <div class="sidebar-header">
                <h1 class="sidebar-title">Deep Search Thinking Bots</h1>
                <div class="sidebar-subtitle">A self-organizing tree of AI agents that collaborate to find answers</div>
            </div>
            <div class="social-links" style="margin-top: 10px; font-size: 0.9rem; color: #6c757d; margin-bottom: 20px;">
                <a href="https://x.com/daveenjay" target="_blank" style="color: #1DA1F2; text-decoration: none;">
                   @DaveenJay
                </a>
            </div>

            <!-- Move input elements to sidebar -->
        <div class="search-container">
            <div class="api-key-input">
                <label for="api-key">OpenAI API Key:</label>
                <input type="password" id="api-key" placeholder="Enter your OpenAI API key" />
            </div>
            <div class="model-selector">
                <label for="model-selector">Select Model:</label>
                <select id="model-selector">
                    <option value="gpt-4o-mini">GPT 4o mini (Fastest, Most Economical)</option>
                    <option value="gpt-4">GPT-4 (Most Capable, Higher Quality)</option>
                    <option value="gpt-4-turbo">GPT-4 Turbo (Balanced Speed & Quality)</option>
                    <option value="gpt-4o">GPT-4o (Latest Model, Best Performance)</option>
                </select>
            </div>
            <textarea id="prompt-input" placeholder="Enter your question or prompt here..."></textarea>
                <div class="button-container" style="display: flex; justify-content: space-between; margin-top: 15px;">
                <button id="search-button">Start Deep Search</button>
                <button id="clear-storage" style="background-color: #6c757d;">Clear Saved Data</button>
            </div>
        </div>

            <!-- Rate limit info in sidebar -->
            <div class="rate-limit-container">
                <div class="rate-limit-header" style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0 10px;">
                    <h5 style="font-size: 0.9rem; margin: 0; color: #6c757d;">Model Limits</h5>
                    <button id="toggle-limit-details" class="toggle-btn" style="background: none; border: none; color: #007bff; font-size: 0.8rem; cursor: pointer; padding: 0;">Show Details</button>
                </div>
                <div id="rate-limit-details" style="display: none;">
                    <div class="rate-limit-stats" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                        <div class="limit-badge" id="limit-tokens-minute" style="background-color: #e9ecef; padding: 3px 6px; border-radius: 4px; font-size: 0.8rem;">TPM: 0</div>
                        <div class="limit-badge" id="limit-requests-minute" style="background-color: #e9ecef; padding: 3px 6px; border-radius: 4px; font-size: 0.8rem;">RPM: 0</div>
                        <div class="limit-badge" id="limit-tokens-day" style="background-color: #e9ecef; padding: 3px 6px; border-radius: 4px; font-size: 0.8rem;">TPD: 0</div>
                        <div class="limit-badge" id="limit-requests-day" style="background-color: #e9ecef; padding: 3px 6px; border-radius: 4px; font-size: 0.8rem;">RPD: 0</div>
            </div>
                    <div class="rate-limit-status">
                        <span>Rate Limit:</span>
                        <div class="progress" style="flex: 1; margin: 0 10px;">
                            <div class="progress-bar" id="rate-limit-bar" style="width: 0%"></div>
                    </div>
                        <span id="rate-limit-percent">0%</span>
                        </div>
                    </div>
                </div>
                
                <!-- Settings button at the bottom of sidebar -->
                <div class="settings-button" id="open-settings">
                    <i class="fas fa-cog"></i> Settings
                </div>
                </div>
                
        <div class="main-content">
            <!-- Loading indicator -->
            <div class="loading" style="display: none;">
                <div class="loading-spinner"></div>
                <div class="loading-text">Processing your query...</div>
            </div>
                
            <!-- Status bar for the main area -->
            <div class="status-bar inactive" id="status-bar">
                <div class="status-indicator"></div>
                <div class="status-text" id="status-text">Ready for input</div>
            </div>
            
            <!-- Segmented Picker for View Switching -->
            <div class="view-selector">
                <button class="view-selector-option active" id="agents-tab">
                    <i class="fas fa-network-wired"></i> Agent Map
                </button>
                <button class="view-selector-option" id="answer-tab">
                    <i class="fas fa-file-alt"></i> Final Answer
                    <span class="notification-dot" id="answer-notification"></span>
                </button>
            </div>
            
            <!-- Agents View Container -->
            <div class="view-container active" id="agents-view">
                <div class="agents-view">
                    <!-- Title is now above the tree container -->
                    <div class="view-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <div>
                            <h4 style="margin: 0;">Agent Collaboration</h4>
                            <small style="color: #6c757d;">Visualizing how agents work together</small>
                        </div>
                    </div>
                    
                    <!-- Banner that appears when an answer is ready -->
                    <div class="answer-ready-banner" id="answer-ready-banner">
                        <span> Your answer is ready! View the final result.</span>
                        <button id="view-answer-btn">View Answer</button>
                    </div>
                    
                    <!-- Main working area for agent visualization -->
                    <div class="tree-container" id="tree-container">
                        <div class="tree-legend" style="margin-bottom: 8px;">
                            <div class="legend-item">
                                <div class="status-badge pending"></div>
                                <span>Pending</span>
                            </div>
                            <div class="legend-item">
                                <div class="status-badge processing"></div>
                                <span>Processing</span>
                            </div>
                            <div class="legend-item">
                                <div class="status-badge completed"></div>
                                <span>Completed</span>
                            </div>
                            <div class="legend-item">
                                <div class="status-badge forwarded"></div>
                                <span>Forwarded</span>
                            </div>
                            <div class="legend-item">
                                <div class="status-badge continued"></div>
                                <span>Continued</span>
                            </div>
                        </div>
                        
                        <div id="tree-view" class="tree-view">
                            <!-- Tree will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Answer View Container -->
            <div class="view-container" id="answer-view">
                <div class="answer-view">
                    <!-- Final answer display -->
                    <div class="result-container" id="result-container">
                        <div class="result-heading">Final Answer</div>
                        <div class="result-content" id="final-answer"></div>
                        
                        <div class="thinking-path">
                            <div class="thinking-path-title">Agent Thinking Path</div>
                            <div id="thinking-path-content"></div>
                        </div>
                        
                        <!-- Button to switch back to Agent Map view -->
                        <div class="view-switch-hint">
                            <button id="view-agents-btn" class="view-switch-button">
                                <i class="fas fa-network-wired"></i> View Agent Map
                            </button>
                            <span>Click to see how agents collaborated to find this answer</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="thinking-detail" style="display: none;">
        <!-- Detailed thinking content will be dynamically added here -->
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-content">
            <div class="settings-header">
                <h2>Settings & Logs</h2>
                <button class="settings-close" id="close-settings">&times;</button>
            </div>
            
            <div class="settings-section">
                <h3>API Settings</h3>
                <p>Configure your API key and default model preferences here.</p>
                <!-- API settings could go here in the future -->
            </div>
            
            <div class="settings-section">
                <h3>Activity Logs</h3>
                <div class="log-container" id="log-container">
                    <div class="log-controls">
                        <button class="log-toggle log-clear" id="clear-logs">Clear Logs</button>
                    </div>
                    <div id="log-entries" style="max-height: 300px; overflow-y: auto; margin-top: 10px; border: 1px solid #eee; padding: 10px; border-radius: 4px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>

    <script>
        // Rate Limiter for managing API limits
        class RateLimiter {
            constructor() {
                // Store rate limits for different models
                this.modelLimits = {
                    'gpt-4o': {
                        tokensPerMinute: 30000,
                        requestsPerMinute: 500,
                        requestsPerDay: 90000,
                        tokensPerDay: null
                    },
                    'gpt-4o-mini': {
                        tokensPerMinute: 200000,
                        requestsPerMinute: 500,
                        requestsPerDay: 10000,
                        tokensPerDay: 2000000
                    },
                    'gpt-3.5-turbo': {
                        tokensPerMinute: 200000,
                        requestsPerMinute: 500,
                        requestsPerDay: 10000,
                        tokensPerDay: 2000000
                    },
                    'gpt-4': {
                        tokensPerMinute: 10000,
                        requestsPerMinute: 500,
                        requestsPerDay: 10000,
                        tokensPerDay: 100000
                    },
                    'gpt-4-turbo': {
                        tokensPerMinute: 30000,
                        requestsPerMinute: 500,
                        requestsPerDay: 90000,
                        tokensPerDay: null
                    }
                };
                
                // Initialize usage tracking
                this.resetUsage();
                
                // Initialize usage history
                this.usageHistory = [];
                
                // Initialize request queue
                this.requestQueue = [];
                this.isProcessingQueue = false;
                
                // Set thresholds for when to start throttling (as a percentage of the limit)
                this.thresholdPercent = 0.8; // Start throttling at 80% of the limit
                
                // Default delay between requests in ms
                this.baseDelay = 200;
                
                // For estimating tokens
                this.tokensPerCharEstimate = 0.25; // Rough estimate for tokens per character
            }
            
            resetUsage() {
                const now = new Date();
                const midnight = new Date(now);
                midnight.setHours(24, 0, 0, 0);
                
                this.usage = {
                    requestsThisMinute: 0,
                    tokensThisMinute: 0,
                    requestsToday: 0,
                    tokensToday: 0,
                    minuteStartTime: now,
                    dayStartTime: now,
                    nextDayReset: midnight
                };
            }
            
            updateTimers() {
                const now = new Date();
                
                // Check if we need to reset minute counters
                if ((now - this.usage.minuteStartTime) >= 60000) {
                    this.usage.requestsThisMinute = 0;
                    this.usage.tokensThisMinute = 0;
                    this.usage.minuteStartTime = now;
                }
                
                // Check if we need to reset day counters
                if (now >= this.usage.nextDayReset) {
                    this.usage.requestsToday = 0;
                    this.usage.tokensToday = 0;
                    this.usage.dayStartTime = now;
                    
                    const midnight = new Date(now);
                    midnight.setHours(24, 0, 0, 0);
                    this.usage.nextDayReset = midnight;
                }
            }
            
            // Estimate tokens from text
            estimateTokens(text) {
                if (!text) return 0;
                
                // More accurate token estimation
                // Roughly 4 characters per token for English text
                const characterCount = text.length;
                
                // Count special tokens that take more space
                const newlines = (text.match(/\n/g) || []).length;
                const urls = (text.match(/https?:\/\/[^\s]+/g) || []).length;
                const codeBlocks = (text.match(/```[\s\S]*?```/g) || []).length;
                
                // Adjust for these special cases
                // Each newline is roughly 0.5-1 token
                // URLs are more token-heavy
                // Code blocks can be densely packed
                const baseEstimate = characterCount * 0.25; // 4 chars per token
                const adjustments = newlines * 0.5 + urls * 5 + codeBlocks * 5;
                
                return Math.ceil(baseEstimate + adjustments);
            }
            
            // Record usage for a request
            recordUsage(modelName, promptText, responseText) {
                this.updateTimers();
                
                // Estimate tokens
                const promptTokens = this.estimateTokens(promptText);
                const responseTokens = this.estimateTokens(responseText);
                const totalTokens = promptTokens + responseTokens;
                
                // Update usage counters
                this.usage.requestsThisMinute++;
                this.usage.tokensThisMinute += totalTokens;
                this.usage.requestsToday++;
                this.usage.tokensToday += totalTokens;
                
                // Add to usage history
                if (!this.usageHistory) {
                    this.usageHistory = [];
                }
                
                this.usageHistory.push({
                    timestamp: Date.now(),
                    model: modelName,
                    promptTokens,
                    responseTokens,
                    totalTokens
                });
                
                // Limit history size to prevent memory issues
                if (this.usageHistory.length > 1000) {
                    this.usageHistory = this.usageHistory.slice(-1000);
                }
                
                return {
                    promptTokens,
                    responseTokens,
                    totalTokens
                };
            }
            
            // Check if we're approaching rate limits
            checkRateLimits(modelName) {
                this.updateTimers();
                const limits = this.modelLimits[modelName] || this.modelLimits['gpt-3.5-turbo']; // Default to gpt-3.5-turbo limits
                
                const minuteRequestPercent = this.usage.requestsThisMinute / limits.requestsPerMinute;
                const minuteTokenPercent = this.usage.tokensThisMinute / limits.tokensPerMinute;
                const dayRequestPercent = this.usage.requestsToday / limits.requestsPerDay;
                const dayTokenPercent = limits.tokensPerDay ? this.usage.tokensToday / limits.tokensPerDay : 0;
                
                // Calculate the highest percentage toward any limit
                const highestPercent = Math.max(
                    minuteRequestPercent,
                    minuteTokenPercent,
                    dayRequestPercent,
                    dayTokenPercent
                );
                
                return {
                    isApproachingLimit: highestPercent >= this.thresholdPercent,
                    isOverLimit: highestPercent >= 1.0,
                    limitPercent: highestPercent,
                    minuteRequestPercent,
                    minuteTokenPercent,
                    dayRequestPercent,
                    dayTokenPercent,
                    timeToNextMinute: 60000 - (new Date() - this.usage.minuteStartTime),
                    timeToNextDay: this.usage.nextDayReset - new Date()
                };
            }
            
            // Calculate dynamic delay based on how close we are to limits
            calculateDelay(modelName) {
                const limits = this.checkRateLimits(modelName);
                
                if (limits.isOverLimit) {
                    // If we're over the limit, calculate wait time until reset
                    if (limits.minuteRequestPercent >= 1.0 || limits.minuteTokenPercent >= 1.0) {
                        // Wait until the next minute
                        return limits.timeToNextMinute + 100; // Add 100ms buffer
                    }
                    
                    if (limits.dayRequestPercent >= 1.0 || limits.dayTokenPercent >= 1.0) {
                        // We hit daily limit, need to notify user
                        throw new Error("Daily API limit reached. Please try again tomorrow.");
                    }
                }
                
                if (limits.isApproachingLimit) {
                    // Scale delay based on how close we are to the limit
                    const scaleFactor = (limits.limitPercent - this.thresholdPercent) / (1 - this.thresholdPercent);
                    const maxDelay = 2000; // Max 2 second delay
                    return this.baseDelay + Math.floor(scaleFactor * (maxDelay - this.baseDelay));
                }
                
                return this.baseDelay;
            }
            
            // Add a request to the queue
            async queueRequest(apiCallFunction, modelName, ...args) {
                return new Promise((resolve, reject) => {
                    this.requestQueue.push({
                        apiCallFunction,
                        modelName,
                        args,
                        resolve,
                        reject
                    });
                    
                    if (!this.isProcessingQueue) {
                        this.processQueue();
                    }
                });
            }
            
            // Process the queue
            async processQueue() {
                if (this.requestQueue.length === 0 || this.isProcessingQueue) {
                    return;
                }
                
                this.isProcessingQueue = true;
                
                try {
                    const request = this.requestQueue.shift();
                    const { apiCallFunction, modelName, args, resolve, reject } = request;
                    
                    // Check rate limits and calculate delay
                    let delay = 0;
                    try {
                        delay = this.calculateDelay(modelName);
                    } catch (error) {
                        // This catches errors like daily limit reached
                        reject(error);
                        this.isProcessingQueue = false;
                        this.processQueue(); // Continue with the next request
                        return;
                    }
                    
                    if (delay > 0) {
                        // Log that we're rate limiting
                        console.log(`Rate limiting: Delaying request by ${delay}ms`);
                        await new Promise(r => setTimeout(r, delay));
                    }
                    
                    // Execute the API call
                    try {
                        const result = await apiCallFunction(...args);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                } catch (error) {
                    console.error("Error processing queue:", error);
                }
                
                this.isProcessingQueue = false;
                this.processQueue(); // Process the next request
            }
            
            // Get current usage statistics
            getUsageStats() {
                const now = Date.now();
                const currentMinute = Math.floor(now / 60000);
                const currentDay = Math.floor(now / 86400000);
                
                // Calculate tokens used in the current minute
                let tokensThisMinute = 0;
                let requestsThisMinute = 0;
                let tokensToday = 0;
                let requestsToday = 0;
                
                // Ensure usageHistory exists before trying to iterate over it
                if (this.usageHistory && Array.isArray(this.usageHistory)) {
                    // Calculate tokens used in the current minute
                    for (const record of this.usageHistory) {
                        if (Math.floor(record.timestamp / 60000) === currentMinute) {
                            tokensThisMinute += record.totalTokens;
                            requestsThisMinute++;
                        }
                        
                        // Calculate tokens used in the current day
                        if (Math.floor(record.timestamp / 86400000) === currentDay) {
                            tokensToday += record.totalTokens;
                            requestsToday++;
                        }
                    }
                } else {
                    // If usageHistory doesn't exist, initialize it
                    this.usageHistory = [];
                }
                
                // Add queue length
                const queueLength = this.requestQueue ? this.requestQueue.length : 0;
                
                return {
                    tokensThisMinute,
                    requestsThisMinute,
                    tokensToday,
                    requestsToday,
                    queueLength
                };
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize rate limiter
            const rateLimiter = new RateLimiter();
            
            const apiKeyInput = document.getElementById('api-key');
            const promptInput = document.getElementById('prompt-input');
            const searchButton = document.getElementById('search-button');
            const clearStorageButton = document.getElementById('clear-storage');
            const resultContainer = document.getElementById('result-container');
            const finalAnswerDiv = document.getElementById('final-answer');
            const thinkingPathContent = document.getElementById('thinking-path-content');
            const treeView = document.getElementById('tree-view');
            const loadingIndicator = document.querySelector('.loading');
            const logContainer = document.getElementById('log-container');
            const logEntries = document.getElementById('log-entries');
            const clearLogsButton = document.getElementById('clear-logs');
            const toggleLimitDetailsButton = document.getElementById('toggle-limit-details');
            const rateLimitDetails = document.getElementById('rate-limit-details');
            
            // View switching elements
            const agentsTab = document.getElementById('agents-tab');
            const answerTab = document.getElementById('answer-tab');
            const agentsView = document.getElementById('agents-view');
            const answerView = document.getElementById('answer-view');
            const answerNotification = document.getElementById('answer-notification');
            const answerReadyBanner = document.getElementById('answer-ready-banner');
            const viewAnswerBtn = document.getElementById('view-answer-btn');
            const viewAgentsBtn = document.getElementById('view-agents-btn');
            
            // Settings panel elements
            const openSettingsButton = document.getElementById('open-settings');
            const settingsPanel = document.getElementById('settings-panel');
            const closeSettingsButton = document.getElementById('close-settings');
            
            // Function to switch between views
            function switchView(viewId) {
                console.log(`Switching view to: ${viewId}`);
                
                // Hide all views
                const viewContainers = document.querySelectorAll('.view-container');
                viewContainers.forEach(container => {
                    container.classList.remove('active');
                    container.style.display = 'none'; // Explicitly hide all containers
                });
                
                // Deactivate all tabs
                const tabs = document.querySelectorAll('.view-selector-option');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Show the selected view
                const selectedView = document.getElementById(viewId);
                selectedView.classList.add('active');
                selectedView.style.display = 'block'; // Explicitly show the selected container
                
                // Activate the corresponding tab
                if (viewId === 'agents-view') {
                    agentsTab.classList.add('active');
                    
                    // If answer is ready, show the banner in the agents view
                    if (document.getElementById('final-answer').textContent.trim() !== '') {
                        answerReadyBanner.classList.add('visible');
                    }
                } else if (viewId === 'answer-view') {
                    answerTab.classList.add('active');
                    // Hide notification when viewing the answer
                    answerNotification.classList.remove('visible');
                }
                
                console.log(`View switched to: ${viewId}, now visible:`, selectedView.style.display);
            }
            
            // Event listeners for view switching
            agentsTab.addEventListener('click', () => switchView('agents-view'));
            answerTab.addEventListener('click', () => switchView('answer-view'));
            viewAnswerBtn.addEventListener('click', () => switchView('answer-view'));
            viewAgentsBtn.addEventListener('click', () => switchView('agents-view'));
            
            // Function to open settings panel
            function openSettings() {
                settingsPanel.style.display = 'flex';
            }
            
            // Function to close settings panel
            function closeSettings() {
                settingsPanel.style.display = 'none';
            }
            
            // Event listeners for settings panel
            openSettingsButton.addEventListener('click', openSettings);
            closeSettingsButton.addEventListener('click', closeSettings);
            
            // Close settings when clicking outside the content
            settingsPanel.addEventListener('click', function(event) {
                if (event.target === settingsPanel) {
                    closeSettings();
                }
            });
            
            // LocalStorage keys
            const API_KEY_STORAGE_KEY = 'deepSearch_apiKey';
            const LAST_PROMPT_STORAGE_KEY = 'deepSearch_lastPrompt';
            const MODEL_STORAGE_KEY = 'deepSearch_model';
            
            // Retrieve values from localStorage if they exist
            function loadFromLocalStorage() {
                try {
                    const savedApiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
                    const savedPrompt = localStorage.getItem(LAST_PROMPT_STORAGE_KEY);
                    const savedModel = localStorage.getItem(MODEL_STORAGE_KEY);
                    
                    if (savedApiKey) {
                        apiKeyInput.value = savedApiKey;
                        logger.info('API key loaded from localStorage');
                    }
                    
                    if (savedPrompt) {
                        promptInput.value = savedPrompt;
                        logger.info('Last prompt loaded from localStorage');
                    }
                    
                    if (savedModel) {
                        document.getElementById('model-selector').value = savedModel;
                        logger.info('Model preference loaded from localStorage');
                    }
                } catch (error) {
                    logger.error(`Error loading from localStorage: ${error.message}`);
                }
            }
            
            // Save values to localStorage
            function saveToLocalStorage(apiKey, prompt, model) {
                try {
                    localStorage.setItem(API_KEY_STORAGE_KEY, apiKey);
                    localStorage.setItem(LAST_PROMPT_STORAGE_KEY, prompt);
                    localStorage.setItem(MODEL_STORAGE_KEY, model);
                    logger.info('Values saved to localStorage');
                } catch (error) {
                    logger.error(`Error saving to localStorage: ${error.message}`);
                }
            }
            
            // Clear localStorage data
            function clearLocalStorage() {
                try {
                    localStorage.removeItem(API_KEY_STORAGE_KEY);
                    localStorage.removeItem(LAST_PROMPT_STORAGE_KEY);
                    localStorage.removeItem(MODEL_STORAGE_KEY);
                    apiKeyInput.value = '';
                    promptInput.value = '';
                    document.getElementById('model-selector').value = 'gpt-3.5-turbo'; // Reset to default
                    logger.info('Cleared saved data from localStorage');
                    alert('Saved data has been cleared');
                } catch (error) {
                    logger.error(`Error clearing localStorage: ${error.message}`);
                }
            }
            
            // Clear storage button event listener
            clearStorageButton.addEventListener('click', clearLocalStorage);
            
            // Logging functionality
            const logger = {
                entries: [],
                
                log: function(message, level = 'info') {
                    const timestamp = new Date().toLocaleTimeString();
                    const entry = {
                        time: timestamp,
                        level: level,
                        message: message
                    };
                    
                    this.entries.push(entry);
                    this.renderEntry(entry);
                    
                    // Auto-scroll to bottom
                    logContainer.scrollTop = logContainer.scrollHeight;
                    
                    // Also log to console for debugging
                    console.log(`[${level.toUpperCase()}] ${message}`);
                },
                
                info: function(message) {
                    this.log(message, 'info');
                },
                
                success: function(message) {
                    this.log(message, 'success');
                },
                
                warning: function(message) {
                    this.log(message, 'warning');
                },
                
                error: function(message) {
                    this.log(message, 'error');
                },
                
                clear: function() {
                    this.entries = [];
                    logEntries.innerHTML = '';
                },
                
                renderEntry: function(entry) {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'log-entry';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'log-time';
                    timeSpan.textContent = entry.time;
                    
                    const levelSpan = document.createElement('span');
                    levelSpan.className = `log-level-${entry.level}`;
                    levelSpan.textContent = `[${entry.level.toUpperCase()}]`;
                    
                    const messageSpan = document.createElement('span');
                    messageSpan.className = 'log-message';
                    messageSpan.textContent = entry.message;
                    
                    entryDiv.appendChild(timeSpan);
                    entryDiv.appendChild(levelSpan);
                    entryDiv.appendChild(messageSpan);
                    
                    logEntries.appendChild(entryDiv);
                }
            };
            
            // Log visibility is now controlled via the settings panel
            // The toggle log button has been removed
            
            // Toggle rate limit details visibility
            toggleLimitDetailsButton.addEventListener('click', function() {
                if (rateLimitDetails.style.display === 'none') {
                    rateLimitDetails.style.display = 'block';
                    toggleLimitDetailsButton.textContent = 'Hide Details';
                } else {
                    rateLimitDetails.style.display = 'none';
                    toggleLimitDetailsButton.textContent = 'Show Details';
                }
            });
            
            // Clear logs
            clearLogsButton.addEventListener('click', function() {
                logEntries.innerHTML = '';
                logger.info('Logs cleared');
            });
            
            // Initial log
            logger.info('Application initialized');
            
            // Load saved values from localStorage
            loadFromLocalStorage();
            
            logger.info('Waiting for user input...');
            
            // Update limit details when model selector changes
            document.getElementById('model-selector').addEventListener('change', function() {
                const selectedModel = this.value;
                if (rateLimitDetails.style.display !== 'none') {
                    updateRateLimitDetails(selectedModel);
                }
            });
            
            // Agent tree for recording the thinking structure
            class Agent {
                constructor(id, name, parentId = null, continuationFromId = null) {
                    this.id = id;
                    this.name = name;
                    this.parentId = parentId;
                    this.childrenIds = [];
                    this.thinking = "";
                    this.status = "created"; // created, processing, completed, forwarded, etc.
                    this.answer = null;
                    this.model = null; // Track which model was used by this agent
                    this.continuationFromId = continuationFromId; // Track if this agent is a continuation from another agent
                    this.continuationToId = null; // Track if this agent continues to another agent
                }
            }
            
            // Agent tree for recording the thinking structure
            class AgentTree {
                constructor() {
                    this.agents = {};
                    this.rootId = null;
                    this.finalAgentId = null;
                    this.nextId = 1;
                    this.selectedAgentId = null;
                }
                
                reset() {
                    this.agents = {};
                    this.rootId = null;
                    this.finalAgentId = null;
                    this.nextId = 1;
                    this.selectedAgentId = null;
                }
                
                createRootAgent(name) {
                    const id = this.nextId++;
                    const agent = new Agent(id, name);
                    this.agents[id] = agent;
                    this.rootId = id;
                    return id;
                }
                
                createChildAgent(parentId, name) {
                    const id = this.nextId++;
                    const agent = new Agent(id, name, parentId);
                    this.agents[id] = agent;
                    
                    // Update the parent's children list
                    const parent = this.agents[parentId];
                    if (parent) {
                        parent.childrenIds.push(id);
                    }
                    
                    return id;
                }
                
                createContinuationAgent(originalAgentId, name) {
                    const id = this.nextId++;
                    const agent = new Agent(id, name, null, originalAgentId); // No parent, but track the original agent
                    this.agents[id] = agent;
                    
                    // Mark the original agent as having a continuation
                    const originalAgent = this.agents[originalAgentId];
                    if (originalAgent) {
                        originalAgent.continuationToId = id;
                    }
                    
                    return id;
                }
                
                getAgent(id) {
                    return this.agents[id];
                }
                
                updateAgentThinking(id, thinking) {
                    const agent = this.agents[id];
                    if (agent) {
                        agent.thinking = thinking;
                    }
                }
                
                updateAgentStatus(id, status) {
                    const agent = this.agents[id];
                    if (agent) {
                        agent.status = status;
                    }
                }
                
                setAgentAnswer(id, answer) {
                    const agent = this.agents[id];
                    if (agent) {
                        agent.answer = answer;
                        agent.status = 'completed';
                        this.finalAgentId = id;
                    }
                }
                
                // Get linear path from root to final agent
                getFinalPath() {
                    if (!this.finalAgentId || !this.rootId) return [];
                    
                    const path = [];
                    let currentId = this.finalAgentId;
                    
                    while (currentId) {
                        const agent = this.agents[currentId];
                        path.unshift({
                            agentName: agent.name,
                            thinking: agent.thinking
                        });
                        currentId = agent.parentId;
                    }
                    
                    return path;
                }
                
                // Get the final answer
                getFinalAnswer() {
                    if (!this.finalAgentId) return null;
                    return this.agents[this.finalAgentId].answer;
                }
                
                // Render the tree visualization
                renderTree() {
                    const treeView = document.getElementById('tree-view');
                    treeView.innerHTML = '';
                    
                    if (!this.rootId) return;
                    
                    // Create an SVG element for drawing connections
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.style.position = 'absolute';
                    svg.style.top = '0';
                    svg.style.left = '0';
                    svg.style.pointerEvents = 'none';
                    svg.classList.add('tree-connector-container');
                    
                    // Create a container for the tree nodes
                    const treeMap = document.createElement('div');
                    treeMap.className = 'tree-map';
                    
                    // Group agents by level (depth in the tree)
                    const levelMap = {};
                    
                    // Calculate level for each agent
                    const calculateLevel = (agentId, level) => {
                        const agent = this.agents[agentId];
                        if (!agent) return;
                        
                        if (!levelMap[level]) {
                            levelMap[level] = [];
                        }
                        
                        levelMap[level].push(agent);
                        
                        // Process children
                        for (const childId of agent.childrenIds) {
                            calculateLevel(childId, level + 1);
                        }
                    };
                    
                    // Start with the root
                    calculateLevel(this.rootId, 0);
                    
                    // Sort levels and render each level
                    const levels = Object.keys(levelMap).sort((a, b) => Number(a) - Number(b));
                    
                    // Create a node for each agent
                    const nodeRefs = {};
                    
                    for (const level of levels) {
                        const levelDiv = document.createElement('div');
                        levelDiv.className = 'tree-level';
                        levelDiv.dataset.level = level;
                        
                        // Sort agents to keep consistent ordering
                        const agentsInLevel = levelMap[level].sort((a, b) => a.id - b.id);
                        
                        for (const agent of agentsInLevel) {
                            // Create a visual display for each node - only create this once
                            const nodeDiv = document.createElement('div');
                            nodeDiv.className = 'node';
                            nodeDiv.dataset.agentId = agent.id;
                            
                            // Add position relative for absolute positioning of indicators
                            nodeDiv.style.position = 'relative';
                            
                            // Highlight the final agent or selected agent
                            if (agent.id === this.finalAgentId || agent.id === this.selectedAgentId) {
                                nodeDiv.classList.add('active');
                            }
                            
                            // Add status indicator
                            let statusClass = 'status-pending';
                            switch (agent.status) {
                                case 'processing':
                                    statusClass = 'status-processing';
                                    break;
                                case 'completed':
                                    statusClass = 'status-completed';
                                    break;
                                case 'forwarded':
                                case 'delegated':
                                case 'branched':
                                    statusClass = 'status-forwarded';
                                    break;
                                case 'continued':
                                    statusClass = 'status-continued';
                                    break;
                            }
                            nodeDiv.classList.add(statusClass);
                            
                            // Add continuation indicators if needed
                            if (agent.continuationToId) {
                                const continuationLink = document.createElement('div');
                                continuationLink.className = 'continuation-link';
                                continuationLink.textContent = '';
                                continuationLink.title = 'This agent continues in another branch';
                                continuationLink.addEventListener('click', (e) => {
                                    e.stopPropagation(); // Prevent triggering the parent node's click
                                    this.showDetailedThinking(agent.continuationToId);
                                });
                                nodeDiv.appendChild(continuationLink);
                            }
                            
                            if (agent.continuationFromId) {
                                const continuationBadge = document.createElement('div');
                                continuationBadge.className = 'continuation-badge';
                                continuationBadge.textContent = '';
                                continuationBadge.title = 'This agent continues from another branch';
                                continuationBadge.style.position = 'absolute';
                                continuationBadge.style.top = '-5px';
                                continuationBadge.style.left = '-5px';
                                continuationBadge.style.width = '15px';
                                continuationBadge.style.height = '15px';
                                continuationBadge.style.backgroundColor = '#17a2b8';
                                continuationBadge.style.borderRadius = '50%';
                                continuationBadge.style.display = 'flex';
                                continuationBadge.style.alignItems = 'center';
                                continuationBadge.style.justifyContent = 'center';
                                continuationBadge.style.color = 'white';
                                continuationBadge.style.fontSize = '10px';
                                continuationBadge.style.cursor = 'pointer';
                                continuationBadge.style.zIndex = '10';
                                continuationBadge.addEventListener('click', (e) => {
                                    e.stopPropagation(); // Prevent triggering the parent node's click
                                    this.showDetailedThinking(agent.continuationFromId);
                                });
                                nodeDiv.appendChild(continuationBadge);
                            }
                            
                            // Add agent name with model badge
                            const nameContainer = document.createElement('div');
                            nameContainer.className = 'node-name-container';
                            
                            const nameSpan = document.createElement('span');
                            nameSpan.className = 'node-name';
                            nameSpan.textContent = agent.name;
                            nameContainer.appendChild(nameSpan);
                            
                            // Add model badge if model is known
                            if (agent.model) {
                                const modelBadge = document.createElement('span');
                                modelBadge.className = 'model-badge';
                                modelBadge.textContent = agent.model.replace('gpt-', '');
                                
                                // Color coding for different models
                                const modelClasses = {
                                    'gpt-4o': 'model-high',
                                    'gpt-4': 'model-high',
                                    'gpt-4-turbo': 'model-medium',
                                    'gpt-3.5-turbo': 'model-low',
                                    'gpt-4o-mini': 'model-low'
                                };
                                
                                if (modelClasses[agent.model]) {
                                    modelBadge.classList.add(modelClasses[agent.model]);
                                }
                                
                                nameContainer.appendChild(modelBadge);
                            }
                            
                            nodeDiv.appendChild(nameContainer);
                            
                            // Add click handler to show detailed thinking
                            nodeDiv.addEventListener('click', () => {
                                this.showDetailedThinking(agent.id);
                            });
                            
                            // Store reference to the node for drawing connections later
                            nodeRefs[agent.id] = nodeDiv;
                            
                            levelDiv.appendChild(nodeDiv);
                        }
                        
                        treeMap.appendChild(levelDiv);
                    }
                    
                    // Add the tree map to the view
                    treeView.appendChild(treeMap);
                    
                    // Add the SVG for connections
                    treeView.appendChild(svg);
                    
                    // Draw connections after nodes are positioned
                    setTimeout(() => {
                        this.drawConnections(svg, nodeRefs);
                    }, 100);
                    
                    // Show detailed thinking for selected agent if any
                    if (this.selectedAgentId) {
                        this.showDetailedThinking(this.selectedAgentId);
                    }
                }
                
                // Draw connections between parent and child nodes
                drawConnections(svg, nodeRefs) {
                    // Process each agent to draw connections to its children
                    for (const agentId in this.agents) {
                        const agent = this.agents[agentId];
                        const parentNode = nodeRefs[agentId];
                        
                        if (!parentNode || !agent.childrenIds.length) continue;
                        
                        // Get parent node position
                        const parentRect = parentNode.getBoundingClientRect();
                        const svgRect = svg.getBoundingClientRect();
                        
                        const parentX = parentRect.left + parentRect.width / 2 - svgRect.left;
                        const parentY = parentRect.bottom - svgRect.top;
                        
                        // Draw connections to each child
                        for (const childId of agent.childrenIds) {
                            const childNode = nodeRefs[childId];
                            if (!childNode) continue;
                            
                            const childRect = childNode.getBoundingClientRect();
                            const childX = childRect.left + childRect.width / 2 - svgRect.left;
                            const childY = childRect.top - svgRect.top;
                            
                            // Create path element for the connection
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            path.classList.add('tree-connector');
                            
                            // Create a curved path from parent to child
                            const midY = parentY + (childY - parentY) / 2;
                            const pathData = `M ${parentX} ${parentY} C ${parentX} ${midY}, ${childX} ${midY}, ${childX} ${childY}`;
                            
                            path.setAttribute('d', pathData);
                            
                            // Add an action indicator on the path
                            const actionIndicator = document.createElement('div');
                            actionIndicator.className = 'tree-action-indicator';
                            
                            // Set position in the middle of the path
                            const indicatorX = (parentX + childX) / 2;
                            const indicatorY = midY;
                            
                            actionIndicator.style.left = `${indicatorX - 15}px`;
                            actionIndicator.style.top = `${indicatorY - 15}px`;
                            
                            // Determine action type
                            if (agent.childrenIds.length > 1) {
                                actionIndicator.textContent = ''; // Branch action
                                actionIndicator.title = 'Branch into multiple specialists';
                            } else {
                                actionIndicator.textContent = ''; // Forward action
                                actionIndicator.title = 'Forward to specialist';
                            }
                            
                            svg.appendChild(path);
                            treeView.appendChild(actionIndicator);
                        }
                    }
                }
                
                // Format thinking text to highlight different thought types
                formatThinking(thinking) {
                    if (!thinking) return '';
                    
                    // Highlight analytical thinking
                    let formatted = thinking.replace(/\b(analyzing|analysis|evaluate|compare|examine|therefore|consequently|thus|hence)\b/gi, 
                        '<span class="thought-type analytical">$1</span>');
                    
                    // Highlight creative thinking
                    formatted = formatted.replace(/\b(imagine|creative|innovative|novel|idea|concept|envision)\b/gi, 
                        '<span class="thought-type creative">$1</span>');
                    
                    // Highlight decision making
                    formatted = formatted.replace(/\b(decide|decision|choose|select|determine|conclude)\b/gi, 
                        '<span class="thought-type decision">$1</span>');
                    
                    // Highlight questions
                    formatted = formatted.replace(/\b(what if|how|why|question|consider|possibility)\b/gi, 
                        '<span class="thought-type questioning">$1</span>');
                    
                    return formatted;
                }
                
                // Show detailed thinking for an agent
                showDetailedThinking(agentId) {
                    const agent = this.agents[agentId];
                    if (!agent) return;
                    
                    this.selectedAgentId = agentId;
                    
                    const thinkingContainer = document.getElementById('thinking-detail');
                    
                    // Make sure the thinking container is visible
                    thinkingContainer.style.display = 'block';
                    
                    // Create and set the header with agent name and model info
                    const headerEl = document.createElement('div');
                    headerEl.className = 'thinking-header';
                    
                    // Add a close button
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '&times;';
                    closeButton.className = 'thinking-close-btn';
                    closeButton.style.float = 'right';
                    closeButton.style.background = 'none';
                    closeButton.style.border = 'none';
                    closeButton.style.fontSize = '1.5rem';
                    closeButton.style.cursor = 'pointer';
                    closeButton.style.padding = '0 10px';
                    closeButton.onclick = function() {
                        thinkingContainer.style.display = 'none';
                    };
                    headerEl.appendChild(closeButton);
                    
                    const titleEl = document.createElement('h3');
                    titleEl.textContent = agent.name;
                    headerEl.appendChild(titleEl);
                    
                    // Add model info if available
                    if (agent.model) {
                        const modelInfo = document.createElement('div');
                        modelInfo.className = 'thinking-model-info';
                        modelInfo.textContent = `Model: ${agent.model}`;
                        headerEl.appendChild(modelInfo);
                    }
                    
                    // Add continuation info if relevant
                    if (agent.continuationFromId || agent.continuationToId) {
                        const continuationInfo = document.createElement('div');
                        continuationInfo.className = 'continuation-info';
                        
                        if (agent.continuationFromId) {
                            const fromAgent = this.agents[agent.continuationFromId];
                            const fromLink = document.createElement('a');
                            fromLink.href = '#';
                            fromLink.textContent = fromAgent ? fromAgent.name : `Agent #${agent.continuationFromId}`;
                            fromLink.addEventListener('click', (e) => {
                                e.preventDefault();
                                this.showDetailedThinking(agent.continuationFromId);
                            });
                            
                            continuationInfo.innerHTML = `<span class="continuation-label">Continued from: </span>`;
                            continuationInfo.appendChild(fromLink);
                        }
                        
                        if (agent.continuationToId) {
                            const toAgent = this.agents[agent.continuationToId];
                            const toLink = document.createElement('a');
                            toLink.href = '#';
                            toLink.textContent = toAgent ? toAgent.name : `Agent #${agent.continuationToId}`;
                            toLink.addEventListener('click', (e) => {
                                e.preventDefault();
                                this.showDetailedThinking(agent.continuationToId);
                            });
                            
                            if (continuationInfo.childNodes.length > 0) {
                                continuationInfo.appendChild(document.createElement('br'));
                            }
                            
                            const labelSpan = document.createElement('span');
                            labelSpan.className = 'continuation-label';
                            labelSpan.textContent = 'Continues to: ';
                            continuationInfo.appendChild(labelSpan);
                            continuationInfo.appendChild(toLink);
                        }
                        
                        headerEl.appendChild(continuationInfo);
                    }
                    
                    // Create the content element
                    const contentEl = document.createElement('div');
                    contentEl.className = 'thinking-content';
                    
                    // Format the thinking text with markdown
                    const formattedThinking = agent.thinking
                        .replace(/\n/g, '<br>')
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>');
                    contentEl.innerHTML = formattedThinking;
                    
                    // Clear previous content and add new elements
                    thinkingContainer.innerHTML = '';
                    thinkingContainer.appendChild(headerEl);
                    thinkingContainer.appendChild(contentEl);
                    
                    // Scroll the thinking pane to the top
                    thinkingContainer.scrollTop = 0;
                    
                    // Update the tree to highlight the selected agent
                    this.renderTree();
                }
            }
            
            const agentTree = new AgentTree();
            
            // Global variables for live visualization
            let liveTree = null;
            let liveStatus = null;
            let activityLog = null;
            let currentThinking = null;
            let activeAgentId = null;
            
            // Add activity to the live visualization log
            function addActivity(message) {
                // Log to console
                console.log(`Activity: ${message}`);
                
                // Add to logs
                logger.info(message);
            }
            
            // Update the currently thinking agent display
            function updateThinkingIndicator(agentName) {
                if (!currentThinking) return;
                
                const agentElement = currentThinking.querySelector('.thinking-agent');
                if (agentElement) {
                    agentElement.textContent = agentName;
                }
            }
            
            // Update the live status message
            function updateLiveStatus(message) {
                // Update status bar
                const statusBar = document.getElementById('status-bar');
                const statusText = document.getElementById('status-text');
                
                if (statusText) {
                    statusText.textContent = message;
                }
                
                // If there's processing happening, make status bar active
                if (message && message !== 'Ready for input') {
                    statusBar.classList.remove('inactive');
                } else {
                    statusBar.classList.add('inactive');
                }
                
                // For backward compatibility, also update legacy live status if it exists
                const liveStatus = document.getElementById('live-status');
                if (liveStatus) {
                liveStatus.textContent = message;
                }
            }
            
            // Render the live tree visualization
            function renderLiveTree(tree) {
                if (!liveTree) return;
                liveTree.innerHTML = '';
                
                if (!tree || !tree.rootId) return;
                
                // Add some descriptive text about the tree visualization
                const desc = document.createElement('div');
                desc.style.fontSize = '0.85rem';
                desc.style.color = '#6c757d';
                desc.style.marginBottom = '15px';
                desc.style.textAlign = 'center';
                desc.innerHTML = 'Colored dots represent agents working on your question.<br>Click any dot to see details.';
                liveTree.appendChild(desc);
                
                // Create and render the root node
                const rootNode = createLiveNode(tree.agents[tree.rootId], tree);
                liveTree.appendChild(rootNode);
            }
            
            // Create a live node for visualization
            function createLiveNode(agent, tree) {
                if (!agent) return null;
                
                const nodeContainer = document.createElement('div');
                nodeContainer.style.display = 'flex';
                nodeContainer.style.flexDirection = 'column';
                nodeContainer.style.alignItems = 'center';
                nodeContainer.style.position = 'relative';
                
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'live-node';
                nodeDiv.dataset.agentId = agent.id;
                
                // Calculate agent depth
                const agentDepth = getAgentDepth(agent.id);
                
                // Add depth indicator for agents at level 3 or 4
                if (agentDepth >= 3) {
                    const depthIndicator = document.createElement('div');
                    depthIndicator.style.position = 'absolute';
                    depthIndicator.style.top = '-16px';
                    depthIndicator.style.right = '-10px';
                    depthIndicator.style.backgroundColor = agentDepth >= 4 ? '#dc3545' : '#ffc107';
                    depthIndicator.style.color = 'white';
                    depthIndicator.style.borderRadius = '50%';
                    depthIndicator.style.width = '16px';
                    depthIndicator.style.height = '16px';
                    depthIndicator.style.fontSize = '10px';
                    depthIndicator.style.display = 'flex';
                    depthIndicator.style.alignItems = 'center';
                    depthIndicator.style.justifyContent = 'center';
                    depthIndicator.style.fontWeight = 'bold';
                    depthIndicator.textContent = agentDepth;
                    
                    // Add a tooltip explaining the depth
                    depthIndicator.title = agentDepth >= 4 ? 
                        "Maximum depth reached - this agent must provide a direct answer" : 
                        "Near maximum depth - next agent will be at max depth";
                    
                    nodeDiv.appendChild(depthIndicator);
                }
                
                // Add status class
                let statusClass = 'pending';
                let statusSymbol = '';
                
                switch (agent.status) {
                    case 'processing':
                        statusClass = 'processing';
                        statusSymbol = '';
                        break;
                    case 'completed':
                        statusClass = 'completed';
                        statusSymbol = '';
                        break;
                    case 'forwarded':
                        statusClass = 'forwarded';
                        statusSymbol = '';
                        break;
                }
                
                nodeDiv.classList.add(statusClass);
                nodeDiv.textContent = statusSymbol;
                
                // Add tooltip with agent name
                const tooltip = document.createElement('div');
                tooltip.className = 'live-node-tooltip';
                tooltip.textContent = agent.name;
                nodeDiv.appendChild(tooltip);
                
                // Add click handler to show thinking in popover
                nodeDiv.addEventListener('click', function() {
                    showLiveNodeDetails(agent, tree);
                });
                
                // Highlight active agent
                if (agent.id === activeAgentId) {
                    nodeDiv.style.boxShadow = '0 0 0 3px rgba(255, 255, 255, 0.8), 0 0 0 5px rgba(0, 123, 255, 0.5)';
                }
                
                nodeContainer.appendChild(nodeDiv);
                
                // Add children if any
                if (agent.childrenIds && agent.childrenIds.length > 0) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'live-node-children';
                    
                    // Add class for multiple children to show horizontal connector
                    if (agent.childrenIds.length > 1) {
                        childrenContainer.classList.add('multiple-children');
                    }
                    
                    // For each child, add a connector
                    for (const childId of agent.childrenIds) {
                        const childAgent = tree.agents[childId];
                        if (childAgent) {
                            const childNode = createLiveNode(childAgent, tree);
                            if (childNode) {
                                // Add connector from child to parent
                                const connector = document.createElement('div');
                                connector.className = 'live-node-connector';
                                childNode.prepend(connector);
                                
                                childrenContainer.appendChild(childNode);
                            }
                        }
                    }
                    
                    nodeContainer.appendChild(childrenContainer);
                }
                
                return nodeContainer;
            }
            
            // Function to show live node details in a popover
            function showLiveNodeDetails(agent, tree) {
                if (!agent) return;
                
                // Remove existing popover if any
                let overlay = document.querySelector('.overlay');
                let popover = document.querySelector('.thinking-popover');
                
                if (overlay) {
                    document.body.removeChild(overlay);
                }
                
                if (popover) {
                    document.body.removeChild(popover);
                }
                
                // Create overlay
                overlay = document.createElement('div');
                overlay.className = 'overlay';
                document.body.appendChild(overlay);
                
                // Create popover
                popover = document.createElement('div');
                popover.className = 'thinking-popover';
                
                // Calculate agent depth
                const agentDepth = getAgentDepth(agent.id);
                
                // Create popover header
                const header = document.createElement('div');
                header.className = 'thinking-popover-header';
                
                const title = document.createElement('div');
                title.className = 'thinking-popover-title';
                title.textContent = agent.name + ' (Live)';
                
                // Add depth indicator if needed
                if (agentDepth > 0) {
                    const depthIndicator = document.createElement('span');
                    depthIndicator.style.marginLeft = '10px';
                    depthIndicator.style.fontSize = '0.8rem';
                    depthIndicator.style.backgroundColor = agentDepth >= 4 ? '#dc3545' : 
                                                           agentDepth >= 3 ? '#ffc107' : '#6c757d';
                    depthIndicator.style.color = 'white';
                    depthIndicator.style.padding = '2px 6px';
                    depthIndicator.style.borderRadius = '4px';
                    depthIndicator.textContent = `Depth: ${agentDepth}`;
                    
                    if (agentDepth >= 4) {
                        depthIndicator.title = "Maximum depth reached - this agent must provide a direct answer";
                    } else if (agentDepth >= 3) {
                        depthIndicator.title = "Near maximum depth - next agent will be at max depth";
                    }
                    
                    title.appendChild(depthIndicator);
                }
                
                const closeButton = document.createElement('button');
                closeButton.className = 'thinking-popover-close';
                closeButton.innerHTML = '&times;';
                closeButton.addEventListener('click', () => {
                    overlay.style.display = 'none';
                    popover.style.display = 'none';
                });
                
                header.appendChild(title);
                header.appendChild(closeButton);
                
                // Create content section
                const content = document.createElement('div');
                content.className = 'thinking-popover-content';
                
                // Create status section
                const statusSection = document.createElement('div');
                statusSection.className = 'thinking-popover-section';
                
                const statusTitle = document.createElement('div');
                statusTitle.className = 'thinking-popover-section-title';
                statusTitle.textContent = 'Agent Status';
                
                let statusText = 'Waiting';
                switch (agent.status) {
                    case 'processing':
                        statusText = 'Currently processing the question';
                        break;
                    case 'completed':
                        statusText = 'Completed with an answer';
                        break;
                    case 'forwarded':
                        statusText = 'Forwarded to specialized agents';
                        break;
                }
                
                const statusContent = document.createElement('div');
                statusContent.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>Current Status:</strong> 
                        <span class="status-badge ${agent.status}">${statusText}</span>
                    </div>
                    <div><strong>Agent ID:</strong> ${agent.id}</div>
                    <div><strong>Parent Agent:</strong> ${agent.parentId ? tree.agents[agent.parentId].name : 'None (Root)'}</div>
                    <div><strong>Depth Level:</strong> ${agentDepth} ${
                        agentDepth >= 4 ? 
                        '<span style="color: #dc3545; font-weight: bold;">(Max Depth - Must Answer Directly)</span>' : 
                        agentDepth === 3 ? 
                        '<span style="color: #ffc107;">(Near Max Depth - Next Level is Final)</span>' : 
                        ''
                    }</div>
                `;
                
                statusSection.appendChild(statusTitle);
                statusSection.appendChild(statusContent);
                content.appendChild(statusSection);
                
                // Create thinking section if agent has thinking
                if (agent.thinking) {
                    const thinkingSection = document.createElement('div');
                    thinkingSection.className = 'thinking-popover-section';
                    
                    const thinkingTitle = document.createElement('div');
                    thinkingTitle.className = 'thinking-popover-section-title';
                    thinkingTitle.textContent = 'Current Thinking';
                    
                    const thinkingContent = document.createElement('div');
                    thinkingContent.innerHTML = tree.formatThinking ? 
                        tree.formatThinking(agent.thinking) : 
                        agent.thinking;
                    
                    thinkingSection.appendChild(thinkingTitle);
                    thinkingSection.appendChild(thinkingContent);
                    content.appendChild(thinkingSection);
                }
                
                // Create children section if agent has children
                if (agent.childrenIds && agent.childrenIds.length > 0) {
                    const childrenSection = document.createElement('div');
                    childrenSection.className = 'thinking-popover-section';
                    
                    const childrenTitle = document.createElement('div');
                    childrenTitle.className = 'thinking-popover-section-title';
                    childrenTitle.textContent = 'Sub-Agents';
                    
                    const childrenContent = document.createElement('div');
                    childrenContent.innerHTML = '<ul style="padding-left: 20px;">' + 
                        agent.childrenIds.map(id => {
                            const childAgent = tree.agents[id];
                            return `<li><strong>${childAgent.name}</strong> - ${childAgent.status}</li>`;
                        }).join('') + 
                        '</ul>';
                    
                    childrenSection.appendChild(childrenTitle);
                    childrenSection.appendChild(childrenContent);
                    content.appendChild(childrenSection);
                }
                
                // Assemble popover
                popover.appendChild(header);
                popover.appendChild(content);
                
                // Add popover to the document
                document.body.appendChild(popover);
                
                // Show overlay and popover
                overlay.style.display = 'block';
                popover.style.display = 'block';
                
                // Close popover with Escape key
                const escKeyHandler = function(e) {
                    if (e.key === 'Escape') {
                        overlay.style.display = 'none';
                        popover.style.display = 'none';
                        document.removeEventListener('keydown', escKeyHandler);
                    }
                };
                
                document.addEventListener('keydown', escKeyHandler);
                
                // Close popover when clicking on overlay
                overlay.addEventListener('click', function(e) {
                    if (e.target === overlay) {
                        overlay.style.display = 'none';
                        popover.style.display = 'none';
                        document.removeEventListener('keydown', escKeyHandler);
                    }
                });
            }
            
            // Initialize the live visualization elements
            function initLiveVisualization() {
                liveTree = document.getElementById('live-tree');
                liveStatus = document.getElementById('live-status');
                activityLog = document.getElementById('activity-log');
                currentThinking = document.getElementById('current-thinking');
            }
            
            // Update rate limit indicator
            function updateRateLimitIndicator(limitInfo) {
                try {
                    if (!limitInfo) return;
                
                    // Update progress bar
                const limitPercent = Math.floor(limitInfo.limitPercent * 100);
                    const rateBar = document.getElementById('rate-limit-bar');
                    const percentEl = document.getElementById('rate-limit-percent');
                    
                    if (rateBar && percentEl) {
                        rateBar.style.width = `${limitPercent}%`;
                        percentEl.textContent = `${limitPercent}%`;
                        
                        // Change bar color based on limit percentage
                        if (limitPercent > 80) {
                            rateBar.style.backgroundColor = '#dc3545'; // Red
                        } else if (limitPercent > 60) {
                            rateBar.style.backgroundColor = '#fd7e14'; // Orange
                        } else {
                            rateBar.style.backgroundColor = '#28a745'; // Green
                        }
                    }
                } catch (error) {
                    console.error("Error updating rate limit indicator:", error);
                }
            }
            
            // Update detailed token and rate limit information
            function updateRateLimitDetails(model) {
                try {
                    if (!model) return;
                    
                // Get current model limits
                const modelLimits = rateLimiter.modelLimits[model] || rateLimiter.modelLimits['gpt-3.5-turbo'];
                    
                    // Safely check for DOM elements before updating
                    const limitTokensMinuteEl = document.getElementById('limit-tokens-minute');
                    const limitRequestsMinuteEl = document.getElementById('limit-requests-minute');
                    const limitTokensDayEl = document.getElementById('limit-tokens-day');
                    const limitRequestsDayEl = document.getElementById('limit-requests-day');
                    
                    // Only update elements if they exist
                    if (limitTokensMinuteEl) {
                        limitTokensMinuteEl.textContent = `TPM: ${modelLimits.tokensPerMinute.toLocaleString()}`;
                    }
                    
                    if (limitRequestsMinuteEl) {
                        limitRequestsMinuteEl.textContent = `RPM: ${modelLimits.requestsPerMinute}`;
                    }
                    
                    if (limitTokensDayEl) {
                        limitTokensDayEl.textContent = `TPD: ${modelLimits.tokensPerDay ? modelLimits.tokensPerDay.toLocaleString() : 'N/A'}`;
                    }
                    
                    if (limitRequestsDayEl) {
                        limitRequestsDayEl.textContent = `RPD: ${modelLimits.requestsPerDay}`;
                    }
                    
                    // Try to get limit info, handling any errors
                    let limitInfo;
                    try {
                        limitInfo = rateLimiter.checkRateLimits(model);
                    } catch (error) {
                        console.warn("Could not check rate limits:", error);
                        return;
                    }
                    
                    // Update rate limit progress bar
                    const rateBar = document.getElementById('rate-limit-bar');
                    const percentEl = document.getElementById('rate-limit-percent');
                    
                    if (rateBar && percentEl && limitInfo) {
                        const percent = Math.floor(limitInfo.limitPercent * 100);
                        rateBar.style.width = `${percent}%`;
                        percentEl.textContent = `${percent}%`;
                        
                        // Change bar color based on limit percentage
                        if (percent > 80) {
                            rateBar.style.backgroundColor = '#dc3545'; // Red
                        } else if (percent > 60) {
                            rateBar.style.backgroundColor = '#fd7e14'; // Orange
                        } else {
                            rateBar.style.backgroundColor = '#28a745'; // Green
                        }
                    }
                } catch (error) {
                    // Log the error but don't throw to prevent breaking the application
                    console.error("Error updating rate limit details:", error);
                }
            }
            
            // Show adaptive rate limit warnings
            function showRateLimitWarning(limitInfo, model) {
                try {
                if (!limitInfo || !model) return;
                
                    // Only show warnings for significant usage
                    if (limitInfo.limitPercent > 0.7) {
                const limitPercent = Math.floor(limitInfo.limitPercent * 100);
                
                        let warningMsg = `Rate limit warning: ${limitPercent}% of ${model} limit used.`;
                        
                    // Suggest switching to less resource-intensive model
                        if ((model === 'gpt-4' || model === 'gpt-4-turbo') && limitPercent > 80) {
                            warningMsg += " Consider switching to gpt-3.5-turbo to avoid hitting limits.";
                        } else if (model === 'gpt-4o' && limitPercent > 80) {
                            warningMsg += " Consider switching to gpt-4o-mini to avoid hitting limits.";
                        }
                        
                        // Log the warning
                        if (logger && typeof logger.warning === 'function') {
                            logger.warning(warningMsg);
                } else {
                            console.warn(warningMsg);
                        }
                        
                        // Update UI status
                        updateLiveStatus(`Rate limit: ${limitPercent}% used - ${limitInfo.nextResetTime} until reset`);
                    }
                } catch (error) {
                    console.error("Error showing rate limit warning:", error);
                }
            }
            
            // Schedule regular rate limit updates (every 5 seconds during processing)
            function startRateLimitUpdates(model) {
                // Initialize with current values
                try {
                    updateRateLimitDetails(model);
                    const initialLimitInfo = rateLimiter.checkRateLimits(model);
                    updateRateLimitIndicator(initialLimitInfo);
                } catch (error) {
                    console.error("Error initializing rate limit display:", error);
                    logger.error(`Failed to initialize rate limit display: ${error.message}`);
                }
                
                // Create a variable to track if the search is still active
                let isSearchActive = true;
                
                const updateInterval = setInterval(() => {
                    try {
                        // Check if the search has completed
                        if (!isSearchActive || searchButton.disabled === false) {
                            clearInterval(updateInterval);
                            return;
                        }
                        
                        // Get current rate limit info and update UI
                        const limitInfo = rateLimiter.checkRateLimits(model);
                        
                        // Update the limit indicators
                        updateRateLimitIndicator(limitInfo);
                        updateRateLimitDetails(model);
                        
                        // Show warnings if approaching limits
                        showRateLimitWarning(limitInfo, model);
                    } catch (error) {
                        console.error("Error updating rate limits:", error);
                        logger.error(`Rate limit update error: ${error.message}`);
                    }
                }, 5000); // Update every 5 seconds
                
                return {
                    interval: updateInterval,
                    setInactive: () => { isSearchActive = false; }
                };
            }
            
            // Function to update the loading text
            function updateLoadingText(message) {
                const loadingTextEl = document.querySelector('.loading-text');
                if (loadingTextEl) {
                    loadingTextEl.textContent = message;
                }
            }
            
            // Function to update the loading visibility
            function showLoading(show, message = 'Processing your query...') {
                // Only show loading during initial setup and final processing,
                // not during the actual agent visualization phase
                const loadingTextEl = document.querySelector('.loading-text');
                if (loadingTextEl) {
                    loadingTextEl.textContent = message;
                }
                
                if (show) {
                    loadingIndicator.style.display = 'flex';
                } else {
                    loadingIndicator.style.display = 'none';
                }
            }
            
            // Update the search button click handler
            searchButton.addEventListener('click', async function() {
                // Hide any open panels
                const thinkingDetail = document.getElementById('thinking-detail');
                if (thinkingDetail) {
                    thinkingDetail.style.display = 'none';
                }
                
                // Show loading indicator initially while setting up
                showLoading(true, 'Starting deep search...');
                searchButton.disabled = true;
                
                // Update status
                updateLiveStatus('Starting deep search process...');
                
                // Reset notifications
                clearAnswerNotifications();
                
                // Reset various UI elements
                finalAnswerDiv.textContent = '';
                thinkingPathContent.innerHTML = '';
                
                // Get input values
                const apiKey = document.getElementById('api-key').value.trim();
                const prompt = document.getElementById('prompt-input').value.trim();
                const model = document.getElementById('model-selector').value;
                
                // Make sure we're viewing the Agents view to start
                switchView('agents-view');
                
                // Clear any previous tree and results
                agentTree.reset();
                
                // Validate inputs
                if (!apiKey) {
                    alert('Please enter your OpenAI API key');
                    showLoading(false);
                    searchButton.disabled = false;
                    updateLiveStatus('Ready for input');
                    return;
                }
                
                if (!prompt) {
                    alert('Please enter a question or prompt');
                    showLoading(false);
                    searchButton.disabled = false;
                    updateLiveStatus('Ready for input');
                    return;
                }
                
                // Declare rate update interval variable outside try-catch for proper scope
                let rateUpdater;
                
                try {
                    saveToLocalStorage(apiKey, prompt, model);
                    logger.info(`Starting deep search with prompt: ${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}`);
                    
                    // Create a root agent for this search
                    agentTree.reset();
                    const rootAgentId = agentTree.createRootAgent('Root Agent');
                    
                    // Start rate limit updates
                    rateUpdater = startRateLimitUpdates(model);
                    
                    // Update limit details display
                    updateRateLimitDetails(model);
                    
                    // Hide loading indicator now that we're about to show the tree
                    // This allows the user to see the agent tree visualization
                    showLoading(false);
                    
                    // Render the initial tree
                    renderLiveTree(agentTree);
                    
                    logger.info(`Using model: ${model}`);
                    
                    // Add debug log
                    console.log("Starting search with root agent:", rootAgentId);
                    
                    // Start the search with the root agent
                    const result = await processWithAgentTree(prompt, apiKey, rootAgentId, model);
                    
                    // Debug the result
                    console.log("Search completed, received result:", result);
                    
                    // Show loading briefly while preparing results
                    showLoading(true, 'Search complete! Preparing results...');
                    
                    // Display the final answer
                    console.log("Setting final answer to:", result);
                    if (result) {
                        // Use innerHTML instead of textContent to properly render content
                        finalAnswerDiv.innerHTML = result.replace(/\n/g, '<br>');
                        
                        // Make sure the result is visible in the DOM
                        console.log("Final answer element:", finalAnswerDiv);
                        console.log("Final answer parent visibility:", finalAnswerDiv.parentElement.style.display);
                        
                        // Ensure result container is visible
                        document.getElementById('result-container').style.display = 'block';
                    } else {
                        console.error("Got empty result from processWithAgentTree");
                        finalAnswerDiv.innerHTML = '<span style="color: red;">No answer was returned. Please try again.</span>';
                    }
                    
                    logger.success('Search completed successfully');
                    
                    // Display thinking path (linear path from root to final agent)
                    const finalPath = agentTree.getFinalPath();
                    logger.info(`Final path includes ${finalPath.length} agents`);
                    
                    // Display each step in the thinking path
                    finalPath.forEach(step => {
                        const botThinkingDiv = document.createElement('div');
                        botThinkingDiv.className = 'bot-thinking';
                        
                        const botNameDiv = document.createElement('div');
                        botNameDiv.className = 'bot-name';
                        botNameDiv.textContent = step.agentName;
                        
                        const thinkingDiv = document.createElement('div');
                        thinkingDiv.textContent = step.thinking;
                        
                        botThinkingDiv.appendChild(botNameDiv);
                        botThinkingDiv.appendChild(thinkingDiv);
                        thinkingPathContent.appendChild(botThinkingDiv);
                    });
                    
                    // Render the tree visualization
                    agentTree.renderTree();
                    
                    // Update status bar
                    updateLiveStatus('Deep search completed successfully');
                    
                    // Show notification that answer is ready
                    showAnswerNotification();
                    
                    // Switch to the answer view using the standard function
                    // This will ensure that tab switching remains functional
                    switchView('answer-view');
                    
                    // Log to confirm the change
                    console.log("Switched to answer view, tabs should remain functional");
                    
                    // Clean up rate limit updates
                    if (rateUpdater) {
                        rateUpdater.setInactive();
                        clearInterval(rateUpdater.interval);
                    }
                } catch (error) {
                    console.error("Error during deep search:", error);
                    logger.error(`Search error: ${error.message}`);
                    alert("An error occurred during the deep search: " + error.message);
                    
                    // Clean up rate limit updates even on error
                    if (rateUpdater) {
                        rateUpdater.setInactive();
                        clearInterval(rateUpdater.interval);
                    }
                    
                    // Update status
                    updateLiveStatus('Search failed: ' + error.message);
                } finally {
                    showLoading(false);
                    searchButton.disabled = false;
                }
            });
            
            async function processWithAgentTree(prompt, apiKey, agentId, model = 'gpt-3.5-turbo') {
                const agent = agentTree.getAgent(agentId);
                if (!agent) {
                    throw new Error(`Agent with ID ${agentId} not found`);
                }
                
                // Update the active agent
                activeAgentId = agentId;
                
                // Store which model this agent is using
                agent.model = model;
                
                logger.info(`Processing with ${agent.name} (ID: ${agentId}, Model: ${model})`);
                agentTree.updateAgentStatus(agentId, 'processing');
                
                // Update status indicators for this agent
                updateLiveStatus(`${agent.name} is analyzing the question...`);
                addActivity(`${agent.name} is now thinking about the problem`);
                
                // Update thinking indicator and render tree
                updateThinkingIndicator(agent.name);
                renderLiveTree(agentTree);
                
                // Update tree visualization
                agentTree.renderTree();
                
                // Determine if we should stop due to maximum depth
                const isMaxDepth = getAgentDepth(agentId) >= 4;
                
                // Create a system message that explains the agent's role and deep search tree capability
                let systemMessage = `You are ${agent.name}, an AI agent in a collaborative tree-based network.

`;

                // Use a different system message for agents at max depth
                if (isMaxDepth) {
                    systemMessage += `IMPORTANT: You have reached the maximum allowed depth in the agent tree (level 4).
You MUST answer the question directly and are NOT ALLOWED to create any new agents.
Regardless of the complexity or nature of the question, you must provide your best answer with the knowledge you have.

Output format (YOU MUST USE THIS FORMAT):
{
    "thinking": "Your detailed reasoning about the question",
    "action": "answer",
    "answer": "Your comprehensive answer to the question"
}`;
                    
                    logger.warning(`Agent ${agent.name} (ID: ${agentId}) has reached maximum depth - restricting to direct answers only`);
                } else {
                    systemMessage += `When you receive a question, you have three options:
1. Answer the question directly if you can provide a high-quality response
2. Create a SINGLE new specialized agent if one specific expert would be better
3. Create MULTIPLE sub-agents (2-3) to tackle different aspects of the question in parallel

If you choose to create new agents, you must:
1. Create specific, descriptive names for each new agent based on their expertise
2. Explain why each specialized agent is needed for this question
3. Specify what aspect of the question each agent should focus on

Output format (for direct answer):
{
    "thinking": "Your detailed reasoning about the question",
    "action": "answer",
    "answer": "Your comprehensive answer to the question"
}

Output format (for creating a single agent):
{
    "thinking": "Your reasoning for why a specialist is needed",
    "action": "forward",
    "newAgent": "Name of the specialized agent",
    "recommendedModel": "Optional model recommendation (gpt-4o, gpt-4-turbo, gpt-4, gpt-4o-mini)"
}

Output format (for creating multiple agents):
{
    "thinking": "Your reasoning for why the question should be split",
    "action": "branch",
    "recommendedModel": "Optional model recommendation (gpt-4o, gpt-4-turbo, gpt-4, gpt-4o-mini)",
    "subAgents": [
        {"name": "First specialized agent name", "focus": "What this agent should focus on", "recommendedModel": "Optional model for this agent"},
        {"name": "Second specialized agent name", "focus": "What this agent should focus on", "recommendedModel": "Optional model for this agent"},
        {"name": "Third specialized agent name", "focus": "What this agent should focus on (optional)", "recommendedModel": "Optional model for this agent"}
    ]
}`;
                }
                
                systemMessage += `\n\nYou can also recommend a specific model for this task or for child agents based on the question complexity:
- gpt-4o-mini: For simple, straightforward questions requiring basic knowledge
- gpt-4-turbo: For moderate complexity requiring deeper reasoning
- gpt-4: For complex tasks requiring detailed reasoning and high accuracy
- gpt-4o: For the most complex tasks requiring advanced reasoning, creativity, or specialized knowledge

This is optional, but helps optimize performance. If not specified, the parent model will be used.`;

                systemMessage += `\n\nIMPORTANT: Always respond in valid JSON format. DO NOT include any text before or after the JSON. Ensure all quotes and brackets are properly balanced. Your entire response must be parseable as valid JSON. Do not include markdown formatting like triple backticks around the JSON.`;
                
                logger.info('Preparing API request to OpenAI');

                // Create a function that makes the actual API call
                const makeApiCall = async () => {
                    logger.info('Sending request to OpenAI API');
                    try {
                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model,
                                messages: [
                                    { role: 'system', content: systemMessage },
                                    { role: 'user', content: prompt }
                                ],
                                temperature: 0.7
                            })
                        });
                        
                        logger.info('Received response from OpenAI API');
                        
                        if (!response.ok) {
                            const errorData = await response.json();
                            // Check if it's a rate limit error
                            if (
                                errorData.error && 
                                (errorData.error.type === 'rate_limit_exceeded' || 
                                 errorData.error.message.includes('rate limit'))
                            ) {
                                logger.warning('Rate limit exceeded. Will retry after delay.');
                                
                                // If rate limit error contains information about retry-after, use that
                                const retryAfter = response.headers.get('retry-after');
                                let retryDelay = 60000; // Default 1 minute
                                
                                if (retryAfter) {
                                    retryDelay = parseInt(retryAfter) * 1000;
                                    logger.info(`Will retry after ${retryDelay/1000} seconds (based on retry-after header)`);
                                }
                                
                                updateLiveStatus(`Rate limit reached. Retrying in ${Math.ceil(retryDelay/1000)} seconds...`);
                                addActivity(`Hit rate limit. Pausing for ${Math.ceil(retryDelay/1000)} seconds.`);
                                
                                // Wait for the specified retry period
                                await new Promise(r => setTimeout(r, retryDelay));
                                
                                // Try again recursively, after the delay
                                return await makeApiCall();
                            }
                            
                            logger.error(`API error: ${errorData.error.message}`);
                            throw new Error(`API error: ${errorData.error.message}`);
                        }
                        
                        const responseData = await response.json();
                        const agentResponse = responseData.choices[0].message.content.trim();

                        // Record the token usage
                        const fullPrompt = systemMessage + prompt;
                        rateLimiter.recordUsage(model, fullPrompt, agentResponse);
                        
                        // Update status with rate limit info
                        const usageStats = rateLimiter.getUsageStats();
                        const rateLimitInfo = rateLimiter.checkRateLimits(model);
                        
                        if (rateLimitInfo.isApproachingLimit) {
                            const limitPercent = Math.floor(rateLimitInfo.limitPercent * 100);
                            logger.warning(`Approaching rate limit: ${limitPercent}% of limit used`);
                            updateLiveStatus(`Rate limiting active (${limitPercent}% of limit used)`);
                        }
                        
                        return agentResponse;
                    } catch (error) {
                        // For network errors, we should retry
                        if (error.name === 'TypeError' && error.message.includes('network')) {
                            logger.warning('Network error. Will retry after short delay.');
                            await new Promise(r => setTimeout(r, 5000));
                            return await makeApiCall();
                        }
                        throw error;
                    }
                };
                
                // Make the API call through the rate limiter
                try {
                    // Queue the API request with the rate limiter
                    const agentResponse = await rateLimiter.queueRequest(makeApiCall, model);
                    
                    logger.info('Successfully received response data');
                    
                    // Parse the JSON response with more robust error handling
                    let parsedResponse;
                    try {
                        // First attempt: try direct JSON parsing
                    try {
                        parsedResponse = JSON.parse(agentResponse);
                        } catch (jsonError) {
                            // If direct parsing fails, try to clean the response
                            logger.warning('Initial JSON parsing failed, attempting to fix response format');
                            
                            // Attempt to extract JSON content (in case there's surrounding text)
                            const jsonMatch = agentResponse.match(/(\{[\s\S]*\})/);
                            
                            if (jsonMatch && jsonMatch[1]) {
                                try {
                                    parsedResponse = JSON.parse(jsonMatch[1]);
                                    logger.info('Successfully parsed JSON after extracting content');
                                } catch (extractError) {
                                    // If extraction doesn't work, try more aggressive fixing
                                    
                                    // Try to ensure proper JSON closure by adding missing brackets if needed
                                    let fixedJson = agentResponse;
                                    
                                    // Count opening and closing braces to detect mismatches
                                    const openBraces = (fixedJson.match(/\{/g) || []).length;
                                    const closeBraces = (fixedJson.match(/\}/g) || []).length;
                                    
                                    // Add missing closing braces if needed
                                    if (openBraces > closeBraces) {
                                        logger.warning(`Detected ${openBraces - closeBraces} missing closing braces, attempting to fix`);
                                        for (let i = 0; i < openBraces - closeBraces; i++) {
                                            fixedJson += '}';
                                        }
                                    }
                                    
                                    try {
                                        parsedResponse = JSON.parse(fixedJson);
                                        logger.info('Successfully parsed JSON after fixing missing brackets');
                                    } catch (fixError) {
                                        // If all automated fixes fail, throw the original error
                                        throw jsonError;
                                    }
                                }
                            } else {
                                // If no JSON-like structure found, try to construct a valid JSON from content
                                logger.warning('No valid JSON structure found, attempting to reconstruct');
                                
                                // Look for key elements that suggest structure
                                const thinkingMatch = agentResponse.match(/thinking["']?\s*:\s*["']([^"']*)["']/);
                                const actionMatch = agentResponse.match(/action["']?\s*:\s*["']([^"']*)["']/);
                                const answerMatch = agentResponse.match(/answer["']?\s*:\s*["']([^"']*)["']/);
                                
                                if (thinkingMatch && actionMatch) {
                                    // Attempt to rebuild a minimal valid JSON
                                    const reconstructed = {
                                        thinking: thinkingMatch[1] || "Error extracting thinking content",
                                        action: actionMatch[1] || "answer"
                                    };
                                    
                                    if (answerMatch) {
                                        reconstructed.answer = answerMatch[1] || "Error extracting answer content";
                                    } else {
                                        reconstructed.answer = "The agent response could not be properly parsed. This is an automatically generated fallback answer.";
                                    }
                                    
                                    parsedResponse = reconstructed;
                                    logger.warning('Created reconstructed JSON from partial matches');
                                } else {
                                    // Last resort: construct a minimal valid response
                                    parsedResponse = {
                                        thinking: "JSON parsing error - could not extract original thinking",
                                        action: "answer",
                                        answer: "There was an error parsing the agent response. Here's the raw response:\n\n" + agentResponse
                                    };
                                    logger.warning('Created fallback JSON when no structure could be recovered');
                                }
                            }
                        }
                        
                        logger.info('Successfully processed agent response');
                    } catch (error) {
                        logger.error('Failed to parse JSON response from agent');
                        logger.error(`Raw response: ${agentResponse.substring(0, 100)}...`);
                        
                        // Create a fallback response
                        parsedResponse = {
                            thinking: "Error parsing JSON response",
                            action: "answer",
                            answer: "There was an error processing the agent's response. This might be due to a formatting issue. Here's the beginning of the raw response:\n\n" + 
                                agentResponse.substring(0, 500) + (agentResponse.length > 500 ? "..." : "")
                        };
                        
                        logger.warning('Using fallback response due to parsing error');
                    }
                    
                    // Update the agent's thinking
                    agentTree.updateAgentThinking(agentId, parsedResponse.thinking);
                    
                    // Force answer if at max depth but agent still tries to create more agents
                    if (isMaxDepth && parsedResponse.action !== 'answer') {
                        logger.warning(`Agent ${agent.name} (ID: ${agentId}) has reached maximum depth - creating continuation branch`);
                        
                        // Instead of forcing an answer, create a continuation agent
                        if (parsedResponse.action === 'forward') {
                            // Create a continuation agent with transferred context
                            const continuationName = `${parsedResponse.newAgent} (Continued)`;
                            const continuationId = agentTree.createContinuationAgent(agentId, continuationName);
                            
                            // Mark the current agent as continued
                            agentTree.updateAgentStatus(agentId, 'continued');
                            addActivity(`${agent.name} reached maximum depth and continued as ${continuationName}`);
                            
                            // Transfer the thinking context to the new agent
                            const continuationContext = `CONTINUATION CONTEXT: This agent continues from ${agent.name} which reached the maximum depth limit (level 4). 
Original thinking from parent agent:
${parsedResponse.thinking}

The parent agent wanted to forward to a specialist named "${parsedResponse.newAgent}".
Please continue with the analysis as this specialist.`;
                            
                            // Process with the continuation agent
                            const selectedModel = parsedResponse.recommendedModel && isValidModel(parsedResponse.recommendedModel) 
                                ? parsedResponse.recommendedModel 
                                : model;
                                
                            logger.info(`Creating continuation with model: ${selectedModel}`);
                            return await processWithAgentTree(continuationContext + "\n\n" + prompt, apiKey, continuationId, selectedModel);
                        } 
                        else if (parsedResponse.action === 'branch') {
                            // Create a continuation agent for synthesis with transferred context
                            const continuationName = `Synthesizer (Continued from ${agent.name})`;
                            const continuationId = agentTree.createContinuationAgent(agentId, continuationName);
                            
                            // Mark the current agent as continued
                            agentTree.updateAgentStatus(agentId, 'continued');
                            addActivity(`${agent.name} reached maximum depth and continued as ${continuationName}`);
                            
                            // Create a specialized context for the continuation agent
                            const subAgentDescriptions = parsedResponse.subAgents.map(sa => 
                                `- ${sa.name}: ${sa.focus}`
                            ).join('\n');
                            
                            const continuationContext = `CONTINUATION CONTEXT: This agent continues from ${agent.name} which reached the maximum depth limit (level 4). 
The original agent wanted to create these specialized agents:
${subAgentDescriptions}

Original thinking:
${parsedResponse.thinking}

Please analyze all these aspects together in an integrated approach.`;
                            
                            // Determine best model to use
                            let selectedModel = model;
                            if (parsedResponse.recommendedModel && isValidModel(parsedResponse.recommendedModel)) {
                                selectedModel = parsedResponse.recommendedModel;
                            } else {
                                // Find the most powerful model recommended by any sub-agent
                                let highestModelIndex = getModelIndex(model);
                                
                                for (const subAgent of parsedResponse.subAgents) {
                                    if (subAgent.recommendedModel && isValidModel(subAgent.recommendedModel)) {
                                        const modelIndex = getModelIndex(subAgent.recommendedModel);
                                        if (modelIndex > highestModelIndex) {
                                            highestModelIndex = modelIndex;
                                            selectedModel = subAgent.recommendedModel;
                                        }
                                    }
                                }
                            }
                            
                            logger.info(`Creating continuation with model: ${selectedModel}`);
                            return await processWithAgentTree(continuationContext + "\n\n" + prompt, apiKey, continuationId, selectedModel);
                        }
                        
                        // Fallback to original behavior if needed
                        logger.error(`Agent ${agent.name} at max depth violated constraints by attempting to ${parsedResponse.action} instead of answering directly.`);
                        addActivity(`${agent.name} was required to answer directly (max depth reached)`);
                        
                        // Create a more informative forced answer
                        parsedResponse.action = 'answer';
                        if (!parsedResponse.answer) {
                            parsedResponse.answer = `[Note: This response was auto-generated because the agent reached maximum tree depth]\n\n${parsedResponse.thinking}\n\nBased on the above analysis, here's the answer to your question:\n`;
                            
                            // If it was trying to forward, mention who it wanted to forward to
                            if (parsedResponse.newAgent) {
                                parsedResponse.answer += `\nThe agent wanted to consult with a "${parsedResponse.newAgent}" specialist, but reached the maximum depth limit.`;
                            }
                            
                            // If it was trying to branch, mention the specialists it wanted to create
                            if (parsedResponse.subAgents && parsedResponse.subAgents.length > 0) {
                                parsedResponse.answer += `\nThe agent wanted to split this question into ${parsedResponse.subAgents.length} parts for specialized analysis by:\n`;
                                parsedResponse.subAgents.forEach(subAgent => {
                                    parsedResponse.answer += `- ${subAgent.name}: ${subAgent.focus}\n`;
                                });
                                parsedResponse.answer += `However, this would exceed the maximum depth limit.`;
                            }
                        }
                    }
                    
                    // Process based on the action
                    if (parsedResponse.action === 'answer') {
                        // Agent provides direct answer
                        logger.success(`${agent.name} provided an answer`);
                        console.log(`Agent ${agent.name} answer:`, parsedResponse.answer);
                        agentTree.setAgentAnswer(agentId, parsedResponse.answer);
                        
                        // Update live visualization
                        updateLiveStatus(`${agent.name} found an answer!`);
                        addActivity(`${agent.name} provided the final answer`);
                        renderLiveTree(agentTree);
                        
                        agentTree.renderTree();
                        return parsedResponse.answer;
                        
                    } else if (parsedResponse.action === 'forward') {
                        // Check if agent recommended a model
                        const childModel = parsedResponse.recommendedModel && isValidModel(parsedResponse.recommendedModel) 
                            ? parsedResponse.recommendedModel 
                            : model;

                        if (parsedResponse.recommendedModel && childModel !== model) {
                            logger.info(`Agent recommended using model ${childModel} instead of ${model}`);
                            addActivity(`${agent.name} recommended using ${childModel} for the child agent`);
                        }
                        
                        // Create the new agent
                        logger.info(`Creating new agent: ${parsedResponse.newAgent}`);
                        
                        // Create a child agent with the specialized agent name
                        const newAgentId = agentTree.createChildAgent(agentId, parsedResponse.newAgent);
                        
                        // Update the UI
                        agentTree.updateAgentStatus(agentId, 'delegated');
                        agentTree.renderTree();
                        
                        addActivity(`${agent.name} created child agent "${parsedResponse.newAgent}"`);
                        
                        // Call the next agent
                        return await processWithAgentTree(prompt, apiKey, newAgentId, childModel);
                        
                    } else if (parsedResponse.action === 'branch') {
                        // Check if agent recommended a base model for children
                        const defaultChildModel = parsedResponse.recommendedModel && isValidModel(parsedResponse.recommendedModel) 
                            ? parsedResponse.recommendedModel 
                            : model;
                        
                        if (parsedResponse.recommendedModel && defaultChildModel !== model) {
                            logger.info(`Agent recommended using model ${defaultChildModel} as default for child agents`);
                            addActivity(`${agent.name} recommended using ${defaultChildModel} as default for child agents`);
                        }

                        // Create multiple sub-agents
                        logger.info(`Creating branch with ${parsedResponse.subAgents.length} sub-agents`);
                        
                        // Mark the current agent as a router
                        agentTree.updateAgentStatus(agentId, 'branched');
                        
                        // Create each sub-agent and record their results
                        const subResults = [];
                        
                        for (const subAgent of parsedResponse.subAgents) {
                            const subAgentId = agentTree.createChildAgent(agentId, subAgent.name);
                            
                            // Get model for this specific sub-agent, fall back to default or parent model
                            const subAgentModel = subAgent.recommendedModel && isValidModel(subAgent.recommendedModel) 
                                ? subAgent.recommendedModel 
                                : defaultChildModel;
                            
                            if (subAgent.recommendedModel && subAgent.recommendedModel !== defaultChildModel) {
                                logger.info(`Using custom model ${subAgent.recommendedModel} for agent "${subAgent.name}"`);
                                addActivity(`Using ${subAgent.recommendedModel} for "${subAgent.name}"`);
                            }
                            
                            // Create a focused prompt for this agent
                            const focusedPrompt = `FOCUS ON THIS SPECIFIC ASPECT: ${subAgent.focus}\n\nORIGINAL QUESTION: ${prompt}`;
                            
                            addActivity(`Branch agent "${subAgent.name}" created with focus: ${subAgent.focus}`);
                            
                            // Process with the sub-agent
                            const subResult = await processWithAgentTree(focusedPrompt, apiKey, subAgentId, subAgentModel);
                            subResults.push({ name: subAgent.name, result: subResult });
                        }
                        
                        // Combine the results
                        const combinedResults = subResults.map(result => `${result.name}:\n${result.result}`).join('\n\n');
                        
                        // Create a synthesis agent to combine the results
                        const synthesisAgentName = `${agent.name} Synthesizer`;
                        const synthesisAgentId = agentTree.createChildAgent(agentId, synthesisAgentName);
                        
                        // Check if any agents have recommended using a more powerful model for synthesis
                        let synthesisModel = model;
                        let highestModelIndex = getModelIndex(model);
                        
                        // Find the most powerful model recommended by any sub-agent
                        for (const subAgent of parsedResponse.subAgents) {
                            if (subAgent.recommendedModel && isValidModel(subAgent.recommendedModel)) {
                                const modelIndex = getModelIndex(subAgent.recommendedModel);
                                if (modelIndex > highestModelIndex) {
                                    highestModelIndex = modelIndex;
                                    synthesisModel = subAgent.recommendedModel;
                                }
                            }
                        }
                        
                        // If we're using a more powerful model for synthesis, log it
                        if (synthesisModel !== model) {
                            logger.info(`Using ${synthesisModel} for synthesis agent based on sub-agent recommendations`);
                            addActivity(`Using ${synthesisModel} for synthesis agent to combine results`);
                        }
                        
                        // Update UI
                        agentTree.updateAgentStatus(synthesisAgentId, 'processing');
                        agentTree.renderTree();
                        
                        updateLiveStatus(`${synthesisAgentName} is integrating the results...`);
                        addActivity(`${synthesisAgentName} is combining insights from all sub-agents`);
                        
                        // Create a synthesis prompt
                        const synthesisPrompt = `Synthesize the following results from multiple specialized agents into a comprehensive answer:
                        
                        ${combinedResults}
                        
Please create a cohesive response that integrates the insights from all agents.`;
                        
                        // Process with the synthesis agent
                        return await processWithAgentTree(synthesisPrompt, apiKey, synthesisAgentId, synthesisModel);
                    } else {
                        // Invalid action
                        logger.error(`Invalid action: ${parsedResponse.action}`);
                        throw new Error(`Invalid action: ${parsedResponse.action}`);
                    }
                    
                } catch (error) {
                    // Handle rate limit errors specially
                    if (error.message && error.message.includes("rate limit")) {
                        logger.warning(`Rate limit error: ${error.message}`);
                        updateLiveStatus(`Rate limit reached. Waiting for limit reset...`);
                        addActivity(`Rate limiting: pausing for a minute to respect API limits`);
                        
                        // Wait for a minute and try again
                        await new Promise(r => setTimeout(r, 61000));
                        return processWithAgentTree(prompt, apiKey, agentId, model);
                    }
                    
                    // Recovery system for repeated errors
                    if (error.message === "The agent did not respond with valid JSON") {
                        // Create a graceful recovery response to avoid cascading failures
                        logger.warning(`Creating recovery response for JSON parsing error`);
                        
                        return `I encountered an issue processing this request. The specific error was: ${error.message}. This might be due to the complexity of the task or a temporary issue with the model.`;
                    }
                    
                    logger.error(`Error in processWithAgentTree: ${error.message}`);
                    throw error;
                }
            }
            
            // Helper function to get agent depth in the tree
            function getAgentDepth(agentId) {
                let depth = 0;
                let currentId = agentId;
                let currentAgent = agentTree.getAgent(currentId);
                
                // For debugging, we'll build a path of agent names
                const path = [];
                
                while (currentAgent && currentAgent.parentId !== null) {
                    depth++;
                    path.unshift(currentAgent.name);
                    currentId = currentAgent.parentId;
                    currentAgent = agentTree.getAgent(currentId);
                }
                
                // Add the root agent name to the path
                if (currentAgent) {
                    path.unshift(currentAgent.name);
                }
                
                // Debug log path only for deeper agents
                if (depth >= 3) {
                    logger.info(`Agent path (depth ${depth}): ${path.join('  ')}`);
                }
                
                return depth;
            }

            // Function to show notification that an answer is available
            function showAnswerNotification() {
                answerNotification.classList.add('visible');
                answerReadyBanner.classList.add('visible');
                
                // Also display a message in the status bar
                updateLiveStatus('Answer ready! Click the "Final Answer" tab to view results.');
            }
            
            function clearAnswerNotifications() {
                answerNotification.classList.remove('visible');
                answerReadyBanner.classList.remove('visible');
            }
        });

        // Add a validation function to ensure the model is valid
        function isValidModel(model) {
            const validModels = ['gpt-4o-mini', 'gpt-4-turbo', 'gpt-4', 'gpt-4o', 'gpt-3.5-turbo'];
            return validModels.includes(model);
        }

        // Add a function to determine model power/capability index
        function getModelIndex(model) {
            const modelOrder = ['gpt-4o-mini', 'gpt-3.5-turbo', 'gpt-4-turbo', 'gpt-4', 'gpt-4o'];
            return modelOrder.indexOf(model);
        }
    </script>
</body>
</html>
